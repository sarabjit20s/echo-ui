// auto-generated file by this script - scripts/build-registry-with-code.ts
// do not edit this file manually

import { RegistryWithCode } from './schema';

export const registryWithCode: RegistryWithCode = [
  {
    name: 'Portal.tsx',
    type: 'component',
    code: "import * as React from 'react';\n\nconst DEFAULT_PORTAL_CONTAINER_ID = 'root';\n\ntype PortalType = {\n  id: string;\n  children: React.ReactNode;\n  containerId: string;\n};\n\ntype SubscriberCallback = (portals: PortalType[]) => void;\n\ntype PortalContextValue = {\n  addContainer: (containerId: string) => void;\n  removeContainer: (containerId: string) => void;\n  addPortal: (portal: PortalType) => void;\n  removePortal: (id: string, containerId: string) => void;\n  subscribe: (containerId: string, callback: SubscriberCallback) => () => void;\n};\n\nconst PortalContext = React.createContext<PortalContextValue | null>(null);\n\nconst usePortal = () => {\n  const context = React.useContext(PortalContext);\n  if (!context) {\n    throw new Error('usePortal must be used within a PortalProvider');\n  }\n  return context;\n};\n\ntype PortalProviderProps = {\n  children: React.ReactNode;\n};\n\nconst PortalProvider = ({ children }: PortalProviderProps) => {\n  const containersRef = React.useRef(new Map<string, boolean>());\n  const portalsRef = React.useRef(new Map<string, PortalType>());\n  const subscribersRef = React.useRef(\n    new Map<string, Set<SubscriberCallback>>(),\n  );\n\n  /**\n   * A function that notifies all subscribers of the containers that are\n   * associated with the given container ID.\n   */\n  const notifySubscribers = React.useCallback((containerId: string) => {\n    const subscribers = subscribersRef.current.get(containerId);\n    if (subscribers) {\n      for (const callback of subscribers) {\n        callback(\n          Array.from(portalsRef.current.values()).filter(\n            p => p.containerId === containerId,\n          ),\n        );\n      }\n    }\n  }, []);\n\n  const addContainer = React.useCallback((id: string) => {\n    if (containersRef.current.has(id)) {\n      throw new Error(`PortalContainer with id '${id}' already exists.`);\n    } else {\n      containersRef.current.set(id, true);\n    }\n  }, []);\n\n  const removeContainer = React.useCallback((id: string) => {\n    if (!containersRef.current.has(id)) {\n      return;\n    }\n    containersRef.current.delete(id);\n  }, []);\n\n  const addPortal = React.useCallback(\n    (portal: PortalType) => {\n      if (containersRef.current.has(portal.containerId)) {\n        portalsRef.current.set(portal.id, portal);\n        notifySubscribers(portal.containerId);\n      } else {\n        throw new Error(\n          `PortalContainer with id '${portal.containerId}' does not exist.`,\n        );\n      }\n    },\n    [notifySubscribers],\n  );\n\n  const removePortal = React.useCallback(\n    (id: string, containerId: string) => {\n      if (containersRef.current.has(containerId)) {\n        portalsRef.current.delete(id);\n        notifySubscribers(containerId);\n      } else {\n        console.warn(\n          `Attempted to remove portal with containerId '${id}', but it does not exist.`,\n        );\n      }\n    },\n    [notifySubscribers],\n  );\n\n  const unsubscribe = React.useCallback(\n    (containerId: string, callback: SubscriberCallback) => {\n      const subscribers = subscribersRef.current.get(containerId);\n      if (subscribers) {\n        subscribers.delete(callback);\n        subscribersRef.current.set(containerId, subscribers);\n      }\n    },\n    [],\n  );\n\n  const subscribe = React.useCallback(\n    (containerId: string, callback: SubscriberCallback) => {\n      const subscribers = subscribersRef.current.get(containerId) || new Set();\n      subscribers.add(callback);\n      subscribersRef.current.set(containerId, subscribers);\n      // return a function to unsubscribe\n      return () => {\n        unsubscribe(containerId, callback);\n      };\n    },\n    [unsubscribe],\n  );\n\n  return (\n    <PortalContext.Provider\n      value={{\n        addContainer,\n        removeContainer,\n        addPortal,\n        removePortal,\n        subscribe,\n      }}>\n      {children}\n      <PortalContainer id={DEFAULT_PORTAL_CONTAINER_ID} />\n    </PortalContext.Provider>\n  );\n};\n\ntype PortalContainerProps = {\n  id: string;\n};\nconst PortalContainer = ({ id }: PortalContainerProps) => {\n  const { addContainer, removeContainer, subscribe } = usePortal();\n  const [portals, setPortals] = React.useState<PortalType[]>([]);\n\n  React.useEffect(() => {\n    addContainer(id);\n    return () => {\n      removeContainer(id);\n    };\n  }, [addContainer, removeContainer, id]);\n\n  React.useEffect(() => {\n    const unsubscribe = subscribe(id, portals => setPortals(portals));\n\n    return () => {\n      unsubscribe();\n    };\n  }, [subscribe, id]);\n\n  return (\n    <React.Fragment>\n      {portals.map(p => (\n        <React.Fragment key={p.id}>{p.children}</React.Fragment>\n      ))}\n    </React.Fragment>\n  );\n};\n\ntype PortalProps = {\n  children?: React.ReactNode;\n  /**\n   * The ID of the container to which the portal will be added.\n   */\n  containerId?: string;\n};\n\nconst Portal = ({\n  children,\n  containerId = DEFAULT_PORTAL_CONTAINER_ID,\n}: PortalProps) => {\n  const { addPortal, removePortal } = usePortal();\n  const id = React.useId();\n\n  React.useEffect(() => {\n    addPortal({ id, children, containerId });\n    return () => {\n      removePortal(id, containerId);\n    };\n  }, [children, id, containerId, addPortal, removePortal]);\n\n  return null;\n};\n\nexport { Portal, PortalProvider, PortalContainer, DEFAULT_PORTAL_CONTAINER_ID };\nexport type { PortalProps, PortalProviderProps, PortalContainerProps };\n",
  },
  {
    name: 'TextArea.tsx',
    type: 'component',
    code: "import * as React from 'react';\nimport {\n  NativeSyntheticEvent,\n  TextInput as RNTextInput,\n  TextInputFocusEventData,\n  TextInputProps as RNTextInputProps,\n} from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport type { Color } from '@/styles/tokens';\n\ntype TextAreaProps = RNTextInputProps & {\n  color?: Color;\n  size?: 'sm' | 'md' | 'lg';\n  variant?: 'ghost' | 'outline' | 'soft';\n};\n\nconst TextArea = React.forwardRef<\n  React.ElementRef<typeof RNTextInput>,\n  TextAreaProps\n>(function TextArea(\n  {\n    cursorColor,\n    multiline = true,\n    placeholderTextColor,\n    selectionColor,\n    color = 'primary',\n    size = 'md',\n    variant = 'outline',\n    textAlignVertical = 'top',\n    onBlur: onBlurProp,\n    onFocus: onFocusProp,\n    style,\n    ...restProps\n  }: TextAreaProps,\n  ref,\n) {\n  const [focused, setFocused] = React.useState<boolean>(false);\n\n  const { styles, theme } = useStyles(stylesheet, {\n    size,\n    variant,\n  });\n\n  const onFocus = React.useCallback(\n    (e: NativeSyntheticEvent<TextInputFocusEventData>) => {\n      setFocused(true);\n      onFocusProp?.(e);\n    },\n    [onFocusProp],\n  );\n  const onBlur = React.useCallback(\n    (e: NativeSyntheticEvent<TextInputFocusEventData>) => {\n      setFocused(false);\n      onBlurProp?.(e);\n    },\n    [onBlurProp],\n  );\n\n  return (\n    <RNTextInput\n      ref={ref}\n      cursorColor={cursorColor || theme.colors[`${color}8`]}\n      placeholderTextColor={placeholderTextColor || theme.colors.neutral10}\n      selectionColor={selectionColor || theme.colors[`${color}8`]}\n      multiline={multiline}\n      textAlignVertical={textAlignVertical}\n      onBlur={onBlur}\n      onFocus={onFocus}\n      style={[styles.textArea(color, focused), style]}\n      {...restProps}\n    />\n  );\n});\n\nconst stylesheet = createStyleSheet(\n  ({ colors, radius, space, typography }) => ({\n    textArea: (color: Color, focused: boolean) => ({\n      width: '100%',\n      flexDirection: 'row',\n      borderRadius: radius.md,\n      borderCurve: 'continuous',\n      fontFamily: typography.fontFamilies.interRegular,\n      variants: {\n        size: {\n          sm: {\n            height: 64,\n            fontSize: typography.fontSizes[14],\n            padding: space[10],\n          },\n          md: {\n            height: 96,\n            fontSize: typography.fontSizes[16],\n            padding: space[12],\n          },\n          lg: {\n            height: 128,\n            fontSize: typography.fontSizes[18],\n            padding: space[16],\n          },\n        },\n        variant: {\n          outline: {\n            borderWidth: 1,\n            borderColor: focused ? colors[`${color}8`] : colors.neutral7,\n            backgroundColor: colors.transparent,\n            color: colors.neutral12,\n          },\n          soft: {\n            backgroundColor: colors[`${color}3`],\n            color: colors[`${color}12`],\n          },\n          ghost: {\n            backgroundColor: colors.transparent,\n            color: colors.neutral12,\n          },\n        },\n      },\n    }),\n  }),\n);\n\nexport { TextArea };\nexport type { TextAreaProps };\n",
  },
  {
    name: 'Spinner.tsx',
    type: 'component',
    dependencies: ['react-native-reanimated', 'react-native-svg'],
    code: "import * as React from 'react';\nimport type { StyleProp, ViewStyle } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  withRepeat,\n  withTiming,\n  Easing,\n  useAnimatedStyle,\n} from 'react-native-reanimated';\nimport Svg, { Circle } from 'react-native-svg';\nimport { useStyles } from 'react-native-unistyles';\n\nimport type { Color, ColorStep } from '@/styles/tokens';\n\nconst AnimatedSvg = Animated.createAnimatedComponent(Svg);\n\ntype SpinnerProps = {\n  color?: Color;\n  colorStep?: ColorStep;\n  highContrast?: boolean;\n  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl';\n  loading?: boolean;\n  style?: StyleProp<ViewStyle>;\n};\n\nconst spinnerSizeMap: Record<NonNullable<SpinnerProps['size']>, number> = {\n  xs: 14,\n  sm: 16,\n  md: 20,\n  lg: 24,\n  xl: 28,\n  '2xl': 36,\n};\n\nconst Spinner = React.forwardRef<React.ElementRef<typeof Svg>, SpinnerProps>(\n  function Spinner({ loading = true, ...restProps }: SpinnerProps, ref) {\n    if (!loading) {\n      return null;\n    }\n    return <SpinnerImpl ref={ref} {...restProps} />;\n  },\n);\n\ntype SpinnerImplProps = Omit<SpinnerProps, 'loading'>;\n\nconst SpinnerImpl = React.forwardRef<\n  React.ElementRef<typeof Svg>,\n  SpinnerImplProps\n>(function SpinnerImpl(\n  {\n    color: colorProp = 'neutral',\n    colorStep,\n    highContrast = false,\n    size: sizeProp = 'md',\n    style,\n  }: SpinnerProps,\n  ref,\n) {\n  const { theme } = useStyles();\n\n  const color =\n    theme.colors[`${colorProp}${colorStep ?? (highContrast ? 12 : 11)}`];\n\n  const size = spinnerSizeMap[sizeProp];\n  const strokeWidth = size / 12;\n  const center = size / 2;\n  const radius = size / 2 - strokeWidth / 2;\n  const circumference = 2 * Math.PI * radius;\n\n  const rotation = useSharedValue(0);\n\n  React.useEffect(() => {\n    rotation.value = withRepeat(\n      withTiming(360, { duration: 600, easing: Easing.linear }),\n      -1,\n    );\n  }, [rotation]);\n\n  const animatedStyles = useAnimatedStyle(() => ({\n    transform: [{ rotate: `${rotation.value}deg` }],\n  }));\n\n  return (\n    <AnimatedSvg\n      ref={ref}\n      width={size}\n      height={size}\n      viewBox={`0 0 ${size} ${size}`}\n      style={[animatedStyles, style]}\n    >\n      <Circle\n        r={radius}\n        cx={center}\n        cy={center}\n        fill={theme.colors.transparent}\n        stroke={color}\n        strokeWidth={strokeWidth}\n        strokeDasharray={`${circumference / 1.5} ${circumference}`} // Single dash\n        strokeLinecap=\"round\"\n      />\n    </AnimatedSvg>\n  );\n});\n\nexport { Spinner };\nexport type { SpinnerProps };\n",
  },
  {
    name: 'Icon.tsx',
    type: 'component',
    dependencies: [
      '@react-native-vector-icons/common',
      '@react-native-vector-icons/ionicons',
    ],
    devDependencies: ['@types/react-native-vector-icons'],
    registryDependencies: [
      {
        name: 'tokens.ts',
        type: 'style',
      },
    ],
    code: "import * as React from 'react';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\nimport Ionicons from '@react-native-vector-icons/ionicons';\n\nimport type { Color, ColorStep } from '@/styles/tokens';\n\ntype IconProps = Omit<\n  React.ComponentPropsWithoutRef<typeof Ionicons>,\n  'color' | 'size'\n> & {\n  color?: Color;\n  colorStep?: ColorStep;\n  highContrast?: boolean;\n  size?:\n    | '2xs'\n    | 'xs'\n    | 'sm'\n    | 'md'\n    | 'lg'\n    | 'xl'\n    | '2xl'\n    | '3xl'\n    | '4xl'\n    | '5xl'\n    | '6xl';\n};\n\nconst Icon = React.forwardRef<React.ElementRef<typeof Ionicons>, IconProps>(\n  function Icon(\n    {\n      name,\n      color = 'neutral',\n      colorStep: colorStepProp,\n      highContrast = false,\n      size = 'md',\n      disabled,\n      style,\n      ...restProps\n    },\n    ref,\n  ) {\n    const { styles, theme } = useStyles(stylesheet, {\n      size,\n    });\n\n    const colorStep: ColorStep = colorStepProp ?? (highContrast ? '12' : '11');\n\n    const iconColor = disabled\n      ? theme.colors.neutral8\n      : theme.colors[`${color}${colorStep}`];\n\n    return (\n      <Ionicons\n        ref={ref}\n        name={name}\n        color={iconColor}\n        disabled={disabled}\n        style={[styles.icon, style]}\n        {...restProps}\n      />\n    );\n  },\n);\n\nconst stylesheet = createStyleSheet(({ space }) => ({\n  icon: {\n    variants: {\n      size: {\n        '2xs': {\n          fontSize: space[10],\n        },\n        xs: {\n          fontSize: space[12],\n        },\n        sm: {\n          fontSize: space[14],\n        },\n        md: {\n          fontSize: space[16],\n        },\n        lg: {\n          fontSize: space[18],\n        },\n        xl: {\n          fontSize: space[20],\n        },\n        '2xl': {\n          fontSize: space[24],\n        },\n        '3xl': {\n          fontSize: space[28],\n        },\n        '4xl': {\n          fontSize: space[32],\n        },\n        '5xl': {\n          fontSize: space[36],\n        },\n        '6xl': {\n          fontSize: space[40],\n        },\n      },\n    },\n  },\n}));\n\nexport { Icon };\nexport type { IconProps };\n",
  },
  {
    name: 'Separator.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
    ],
    code: "import * as React from 'react';\nimport { View } from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\nimport type { Color, ColorStep } from '@/styles/tokens';\n\ntype SeparatorProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T> & {\n    color?: Color;\n    colorStep?: ColorStep;\n    orientation?: 'horizontal' | 'vertical';\n    type?: 'hairline' | 'pixel' | 'cell' | 'section';\n  };\n\nconst Separator = genericForwardRef(function Separator<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    color = 'neutral',\n    colorStep = '6',\n    orientation = 'horizontal',\n    type = 'cell',\n    style,\n    ...restProp\n  }: SeparatorProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { styles } = useStyles(stylesheet, {\n    type,\n  });\n\n  const Comp = as || View;\n\n  return (\n    <Comp\n      ref={ref}\n      style={[styles.separator(color, colorStep, orientation), style]}\n      {...restProp}\n    />\n  );\n});\n\nconst stylesheet = createStyleSheet(({ colors }, rt) => ({\n  separator: (\n    color: Color,\n    colorStep: ColorStep,\n    orientation: SeparatorProps['orientation'],\n  ) => {\n    const isHorizontal = orientation === 'horizontal';\n    return {\n      flexShrink: 1,\n      backgroundColor: colors[`${color}${colorStep}`],\n      variants: {\n        type: {\n          hairline: {\n            width: isHorizontal ? '100%' : rt.hairlineWidth,\n            height: isHorizontal ? rt.hairlineWidth : '100%',\n          },\n          pixel: {\n            width: isHorizontal ? '100%' : 1,\n            height: isHorizontal ? 1 : '100%',\n          },\n          cell: {\n            width: isHorizontal ? '100%' : 2,\n            height: isHorizontal ? 2 : '100%',\n          },\n          section: {\n            width: isHorizontal ? '100%' : 6,\n            height: isHorizontal ? 6 : '100%',\n          },\n        },\n      },\n    };\n  },\n}));\n\nexport { Separator };\nexport type { SeparatorProps };\n",
  },
  {
    name: 'TextInput.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
    ],
    code: "import * as React from 'react';\nimport {\n  NativeSyntheticEvent,\n  TextInput as RNTextInput,\n  TextInputFocusEventData,\n  TextInputProps as RNTextInputProps,\n  View,\n  ViewProps,\n} from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\nimport type { Color } from '@/styles/tokens';\n\ntype TextInputContextValue = {\n  size: 'sm' | 'md' | 'lg';\n  variant: 'ghost' | 'outline' | 'soft';\n};\n\nconst TextInputContext = React.createContext<TextInputContextValue | null>(\n  null,\n);\n\nconst useTextInput = () => {\n  const context = React.useContext(TextInputContext);\n  if (!context) {\n    throw new Error('useTextInput must be used within a <TextInput />');\n  }\n  return context;\n};\n\ntype TextInputProps = Omit<RNTextInputProps, 'style'> & {\n  color?: Color;\n  size?: 'sm' | 'md' | 'lg';\n  variant?: 'ghost' | 'outline' | 'soft';\n  startAdornment?: React.ReactNode;\n  endAdornment?: React.ReactNode;\n  containerStyle?: ViewProps['style'];\n  textInputStyle?: RNTextInputProps['style'];\n};\n\nconst TextInput = React.forwardRef<\n  React.ElementRef<typeof RNTextInput>,\n  TextInputProps\n>(function TextInput(\n  {\n    color = 'primary',\n    size = 'md',\n    variant = 'outline',\n    cursorColor,\n    placeholderTextColor,\n    selectionColor,\n    startAdornment,\n    endAdornment,\n    onBlur: onBlurProp,\n    onFocus: onFocusProp,\n    textInputStyle: textInputStyleProp,\n    containerStyle,\n    ...restProps\n  }: TextInputProps,\n  ref,\n) {\n  const [focused, setFocused] = React.useState(false);\n\n  const { styles, theme } = useStyles(stylesheet, {\n    size,\n    variant,\n  });\n\n  const hasStartAdornment = !!startAdornment;\n  const hasEndAdornment = !!endAdornment;\n\n  const textInputStyle = React.useMemo(() => {\n    return styles.textInput(\n      color,\n      hasStartAdornment && hasEndAdornment\n        ? 'none'\n        : hasStartAdornment\n          ? 'paddingEnd'\n          : hasEndAdornment\n            ? 'paddingStart'\n            : 'paddingHorizontal',\n    );\n  }, [color, hasEndAdornment, hasStartAdornment, styles]);\n\n  const onFocus = React.useCallback(\n    (e: NativeSyntheticEvent<TextInputFocusEventData>) => {\n      setFocused(true);\n      onFocusProp?.(e);\n    },\n    [onFocusProp],\n  );\n  const onBlur = React.useCallback(\n    (e: NativeSyntheticEvent<TextInputFocusEventData>) => {\n      setFocused(false);\n      onBlurProp?.(e);\n    },\n    [onBlurProp],\n  );\n\n  return (\n    <TextInputContext.Provider value={{ size, variant }}>\n      <View style={[styles.container(color, focused), containerStyle]}>\n        {startAdornment}\n        <RNTextInput\n          ref={ref}\n          cursorColor={cursorColor || theme.colors[`${color}8`]}\n          placeholderTextColor={placeholderTextColor || theme.colors.neutral10}\n          selectionColor={selectionColor || theme.colors[`${color}8`]}\n          onBlur={onBlur}\n          onFocus={onFocus}\n          style={[textInputStyle, textInputStyleProp]}\n          {...restProps}\n        />\n        {endAdornment}\n      </View>\n    </TextInputContext.Provider>\n  );\n});\n\ntype TextInputAdornmentProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T> & {\n    type?: 'action' | 'simple';\n  };\n\nconst TextInputAdornment = genericForwardRef(function TextInputAdornment<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  { as, type = 'simple', style, ...restProps }: TextInputAdornmentProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { size, variant } = useTextInput();\n  const { styles } = useStyles(stylesheet, { size, variant });\n\n  const Comp = as || View;\n\n  return (\n    <Comp\n      ref={ref}\n      style={[\n        type === 'action'\n          ? styles.actionAdornmentContainer\n          : styles.simpleAdornmentContainer,\n        style,\n      ]}\n      {...restProps}\n    />\n  );\n});\n\nconst stylesheet = createStyleSheet(\n  ({ colors, radius, space, typography }) => ({\n    container: (color: Color, focused: boolean) => ({\n      width: '100%',\n      flexDirection: 'row',\n      borderRadius: radius.md,\n      borderCurve: 'continuous',\n      variants: {\n        size: {\n          sm: {\n            height: 36,\n          },\n          md: {\n            height: 44,\n          },\n          lg: {\n            height: 52,\n          },\n        },\n        variant: {\n          outline: {\n            borderWidth: 1,\n            borderColor: focused ? colors[`${color}8`] : colors.neutral7,\n            backgroundColor: colors.transparent,\n          },\n          soft: {\n            backgroundColor: colors[`${color}3`],\n          },\n          ghost: {\n            backgroundColor: colors.transparent,\n          },\n        },\n      },\n    }),\n    textInput: (\n      color: Color,\n      paddingKey: 'paddingEnd' | 'paddingHorizontal' | 'paddingStart' | 'none',\n    ) => ({\n      width: '100%',\n      flexShrink: 1,\n      fontFamily: typography.fontFamilies.interRegular,\n      variants: {\n        size: {\n          sm: {\n            fontSize: typography.fontSizes[14],\n            [paddingKey]: space[8],\n          },\n          md: {\n            fontSize: typography.fontSizes[16],\n            [paddingKey]: space[12],\n          },\n          lg: {\n            fontSize: typography.fontSizes[18],\n            [paddingKey]: space[16],\n          },\n        },\n        variant: {\n          outline: {\n            color: colors.neutral12,\n          },\n          soft: {\n            color: colors[`${color}12`],\n          },\n          ghost: {\n            color: colors.neutral12,\n          },\n        },\n      },\n    }),\n    simpleAdornmentContainer: {\n      justifyContent: 'center',\n      variants: {\n        size: {\n          sm: {\n            paddingHorizontal: space[10],\n          },\n          md: {\n            paddingHorizontal: space[12],\n          },\n          lg: {\n            paddingHorizontal: space[16],\n          },\n        },\n      },\n    },\n    actionAdornmentContainer: {\n      justifyContent: 'center',\n      paddingHorizontal: space[4],\n    },\n  }),\n);\n\nexport { TextInput, TextInputAdornment, useTextInput };\nexport type { TextInputProps, TextInputAdornmentProps };\n",
  },
  {
    name: 'Text.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
      {
        name: 'tokens.ts',
        type: 'style',
      },
    ],
    code: "import * as React from 'react';\nimport { Text as RNText } from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\nimport type { Color, ColorStep } from '@/styles/tokens';\nimport {\n  fontFamilies,\n  type FontSize,\n  type TextVariants,\n} from '@/styles/tokens';\n\ntype TextProps<T extends React.ElementType = typeof RNText> =\n  PolymorphicProps<T> & {\n    color?: Color;\n    colorStep?: ColorStep;\n    fontFamily?: keyof typeof fontFamilies;\n    fontSize?: FontSize;\n    textAlign?: 'auto' | 'left' | 'center' | 'right' | 'justify';\n    highContrast?: boolean;\n    /**\n     * Set `true` to inherit the styles from parent Text component instead of using default values\n     */\n    inherit?: boolean;\n    variant?: keyof TextVariants;\n  };\n\nconst defaultColor: Color = 'neutral';\nconst defaultVariant: keyof TextVariants = 'bodyMd';\n\nconst Text = genericForwardRef(function Text<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof RNText>>,\n>(\n  {\n    as,\n    color,\n    colorStep,\n    variant,\n    highContrast = false,\n    fontFamily,\n    fontSize,\n    textAlign = 'auto',\n    disabled,\n    inherit = false,\n    style,\n    ...restProps\n  }: TextProps<T>,\n  ref: React.ForwardedRef<T>,\n) {\n  const { styles } = useStyles(stylesheet);\n\n  const Comp = as || RNText;\n\n  return (\n    <Comp\n      ref={ref}\n      disabled={disabled}\n      style={[\n        inherit && !color\n          ? null\n          : styles.color(color || defaultColor, highContrast, colorStep),\n        inherit && !variant ? null : styles.variant(variant || defaultVariant),\n        fontSize && styles.fontSize(fontSize),\n        fontFamily && styles.fontFamily(fontFamily),\n        textAlign && styles.textAlign(textAlign),\n        disabled && styles.disabled,\n        style,\n      ]}\n      {...restProps}\n    />\n  );\n});\n\nconst stylesheet = createStyleSheet((theme) => ({\n  color: (color: Color, highContrast: boolean, colorStep?: ColorStep) => ({\n    color: theme.colors[`${color}${colorStep ?? (highContrast ? '12' : '11')}`],\n  }),\n  variant: (variant: keyof TextVariants) => ({\n    ...theme.typography.textVariants[variant],\n  }),\n  fontSize: (fontSize: FontSize) => ({\n    fontSize: theme.typography.fontSizes[fontSize],\n  }),\n  fontFamily: (fontFamily: keyof typeof fontFamilies) => ({\n    fontFamily: theme.typography.fontFamilies[fontFamily],\n  }),\n  textAlign: (textAlign: 'auto' | 'left' | 'center' | 'right' | 'justify') => ({\n    textAlign,\n  }),\n  disabled: {\n    color: theme.colors.neutral8,\n  },\n}));\n\nexport { Text };\nexport type { TextProps };\n",
  },
  {
    name: 'Collapsible.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'useControllableState.ts',
        type: 'hook',
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
    ],
    dependencies: ['react-native-reanimated'],
    code: "import * as React from 'react';\nimport {\n  GestureResponderEvent,\n  LayoutChangeEvent,\n  Pressable,\n  View,\n  ViewProps,\n} from 'react-native';\nimport Animated, {\n  Easing,\n  FadeIn,\n  FadeOut,\n  ReduceMotion,\n  useAnimatedStyle,\n  useSharedValue,\n  withTiming,\n} from 'react-native-reanimated';\n\nimport { useControllableState } from '@/hooks/useControllableState';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\n\nconst animConfig = {\n  duration: 200,\n  easing: Easing.out(Easing.ease),\n  reduceMotion: ReduceMotion.System,\n} as const;\n\ntype CollapsibleContextValue = {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  disabled: boolean;\n};\n\nconst CollapsibleContext = React.createContext<CollapsibleContextValue | null>(\n  null,\n);\n\nconst useCollapsible = () => {\n  const ctx = React.useContext(CollapsibleContext);\n  if (!ctx) {\n    throw new Error('useCollapsible must be used within a <Collapsible />');\n  }\n  return ctx;\n};\n\ntype CollapsibleProps = {\n  children: React.ReactNode;\n  defaultOpen?: boolean;\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  disabled?: boolean;\n};\n\nconst Collapsible = ({\n  children,\n  defaultOpen,\n  open: openProp,\n  onOpenChange: onOpenChangeProp,\n  disabled = false,\n}: CollapsibleProps) => {\n  const [open, setOpen] = useControllableState({\n    defaultValue: defaultOpen ?? false,\n    controlledValue: openProp,\n    onControlledChange: onOpenChangeProp,\n  });\n\n  return (\n    <CollapsibleContext.Provider\n      value={{ open, onOpenChange: setOpen, disabled }}\n    >\n      {children}\n    </CollapsibleContext.Provider>\n  );\n};\n\ntype CollapsibleTriggerProps<T extends React.ElementType = typeof Pressable> =\n  Omit<PolymorphicProps<T>, 'children'> & {\n    children?:\n      | React.ReactNode\n      | ((state: { disabled: boolean; expanded: boolean }) => React.ReactNode);\n  };\n\nconst CollapsibleTrigger = genericForwardRef(function CollapsibleTrigger<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  {\n    as,\n    accessibilityState,\n    children,\n    disabled: disabledProp,\n    onPress: onPressProp,\n    ...restProps\n  }: CollapsibleTriggerProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { open, onOpenChange, disabled: ctxDisabled } = useCollapsible();\n\n  const disabled = disabledProp ?? ctxDisabled;\n\n  const onPress = React.useCallback(\n    (e: GestureResponderEvent) => {\n      onOpenChange(!open);\n      onPressProp?.(e);\n    },\n    [onOpenChange, open, onPressProp],\n  );\n\n  const Comp = as || Pressable;\n\n  return (\n    <Comp\n      ref={ref}\n      accessibilityRole=\"button\"\n      accessibilityState={{\n        expanded: open,\n        disabled,\n        ...accessibilityState,\n      }}\n      disabled={disabled}\n      onPress={onPress}\n      {...restProps}\n    >\n      {typeof children === 'function'\n        ? children({ disabled, expanded: open })\n        : children}\n    </Comp>\n  );\n});\n\ntype CollapsibleContentProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T>;\n\nconst CollapsibleContent = genericForwardRef(function CollapsibleContent<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  { as, ...restProps }: CollapsibleContentProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { open } = useCollapsible();\n\n  const height = useSharedValue(0);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      width: '100%',\n      height: open\n        ? withTiming(height.value, animConfig)\n        : withTiming(0, animConfig),\n      overflow: 'hidden',\n    };\n  });\n\n  const containerStyle: ViewProps['style'] = React.useMemo(\n    () => ({\n      position: 'absolute',\n      width: '100%',\n    }),\n    [],\n  );\n\n  const onLayout = React.useCallback(\n    (e: LayoutChangeEvent) => {\n      height.value = e.nativeEvent.layout.height;\n    },\n    [height],\n  );\n\n  const Comp = as || View;\n\n  return (\n    <Animated.View style={animatedStyle}>\n      {open && (\n        <Animated.View\n          entering={FadeIn.duration(animConfig.duration)\n            .easing(animConfig.easing)\n            .reduceMotion(animConfig.reduceMotion)}\n          exiting={FadeOut.duration(animConfig.duration)\n            .easing(animConfig.easing)\n            .reduceMotion(animConfig.reduceMotion)}\n          onLayout={onLayout}\n          style={containerStyle}\n        >\n          <Comp ref={ref} {...restProps} />\n        </Animated.View>\n      )}\n    </Animated.View>\n  );\n});\n\nexport { Collapsible, CollapsibleTrigger, CollapsibleContent, useCollapsible };\nexport type {\n  CollapsibleProps,\n  CollapsibleTriggerProps,\n  CollapsibleContentProps,\n};\n",
  },
  {
    name: 'RadioGroup.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'useControllableState.ts',
        type: 'hook',
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
    ],
    code: "import * as React from 'react';\nimport { GestureResponderEvent, Pressable, View } from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport { useControllableState } from '@/hooks/useControllableState';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\nimport type { Color, ColorStep } from '@/styles/tokens';\n\ntype RadioGroupColor = Color;\ntype RadioGroupSize = 'sm' | 'md' | 'lg';\ntype RadioGroupVariant = 'solid' | 'soft' | 'outline' | 'ghost';\n\ntype RadioGroupContextValue = {\n  color: RadioGroupColor;\n  disabled?: boolean;\n  onValueChange?: (value: string) => void;\n  size: RadioGroupSize;\n  value: string;\n  variant: RadioGroupVariant;\n  highContrast: boolean;\n};\n\nconst RadioGroupContext = React.createContext<RadioGroupContextValue | null>(\n  null,\n);\n\nconst useRadioGroup = () => {\n  const ctx = React.useContext(RadioGroupContext);\n  if (!ctx) {\n    throw new Error('useRadioGroup must be used within a <RadioGroup />');\n  }\n  return ctx;\n};\n\ntype RadioGroupProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T> & {\n    defaultValue?: string;\n    value?: string;\n    onValueChange?: (value: string) => void;\n    disabled?: boolean;\n    color?: RadioGroupColor;\n    size?: RadioGroupSize;\n    variant?: RadioGroupVariant;\n    highContrast?: boolean;\n  };\n\nconst RadioGroup = genericForwardRef(function RadioGroup<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    defaultValue,\n    value: valueProp,\n    onValueChange: onValueChangeProp,\n    disabled,\n    color = 'primary',\n    size = 'md',\n    variant = 'solid',\n    highContrast = false,\n    ...restProps\n  }: RadioGroupProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const [value, onValueChange] = useControllableState({\n    defaultValue: defaultValue ?? '',\n    controlledValue: valueProp,\n    onControlledChange: onValueChangeProp,\n  });\n\n  const Comp = as || View;\n\n  return (\n    <RadioGroupContext.Provider\n      value={{\n        color,\n        disabled,\n        onValueChange,\n        size,\n        value,\n        variant,\n        highContrast,\n      }}\n    >\n      <Comp ref={ref} accessibilityRole=\"radiogroup\" {...restProps} />\n    </RadioGroupContext.Provider>\n  );\n});\n\ntype RadioGroupItemContextValue = {\n  checked: boolean;\n  disabled: boolean;\n};\n\nconst RadioGroupItemContext =\n  React.createContext<RadioGroupItemContextValue | null>(null);\n\nconst useRadioGroupItem = () => {\n  const context = React.useContext(RadioGroupItemContext);\n  if (!context) {\n    throw new Error(\n      'useRadioGroupItem must be used within a <RadioGroupItem />',\n    );\n  }\n  return context;\n};\n\ntype RadioGroupItemProps<T extends React.ElementType = typeof Pressable> =\n  PolymorphicProps<T> & {\n    value: string;\n  };\n\nconst RadioGroupItem = genericForwardRef(function RadioGroupItem<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  {\n    as,\n    accessibilityState,\n    value,\n    disabled: disabledProp,\n    onPress: onPressProp,\n    ...restProps\n  }: RadioGroupItemProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const ctx = useRadioGroup();\n\n  const checked = ctx.value === value;\n  const disabled = disabledProp ?? ctx?.disabled;\n\n  const onPress = React.useCallback(\n    (e: GestureResponderEvent) => {\n      ctx?.onValueChange?.(value);\n      onPressProp?.(e);\n    },\n    [ctx, onPressProp, value],\n  );\n\n  const Comp = as || Pressable;\n\n  return (\n    <RadioGroupItemContext.Provider value={{ checked, disabled: !!disabled }}>\n      <Comp\n        ref={ref}\n        accessibilityRole=\"radio\"\n        accessibilityState={{ checked, disabled }}\n        disabled={disabled}\n        onPress={onPress}\n        {...restProps}\n      />\n    </RadioGroupItemContext.Provider>\n  );\n});\n\ntype RadioGroupIndicatorProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T>;\n\nconst RadioGroupIndicator = genericForwardRef(function RadioGroupIndicator<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    children: childrenProp,\n    style,\n    ...restProps\n  }: RadioGroupIndicatorProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { color, size, variant, highContrast } = useRadioGroup();\n  const { checked, disabled } = useRadioGroupItem();\n\n  const { styles } = useStyles(stylesheet, {\n    size,\n    variant,\n  });\n\n  const colorStep: ColorStep =\n    variant === 'solid' ? 'Contrast' : highContrast ? '12' : '11';\n\n  const children = childrenProp ?? (\n    // default indicator\n    <View\n      style={[\n        styles.innerCircle(color, colorStep),\n        disabled && styles.innerCircleDisabled,\n      ]}\n    />\n  );\n\n  const Comp = as || View;\n\n  return (\n    <Comp\n      ref={ref}\n      style={[\n        styles.outerCircle(checked, color),\n        disabled && styles.outerCircleDisabled,\n        style,\n      ]}\n      {...restProps}\n    >\n      {checked && children}\n    </Comp>\n  );\n});\n\nconst stylesheet = createStyleSheet(({ colors, radius }) => ({\n  outerCircle: (checked: boolean, color: Color) => ({\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderRadius: radius.full,\n    variants: {\n      size: {\n        sm: {\n          width: 16,\n          height: 16,\n        },\n        md: {\n          width: 20,\n          height: 20,\n        },\n        lg: {\n          width: 24,\n          height: 24,\n        },\n      },\n      variant: {\n        ghost: {},\n        outline: {\n          borderWidth: 1,\n          borderColor: colors[`${color}7`],\n          backgroundColor: colors.transparent,\n        },\n        soft: {\n          backgroundColor: colors[`${color}4`],\n        },\n        solid: {\n          borderWidth: 1,\n          borderColor: checked ? colors[`${color}9`] : colors.neutral7,\n          backgroundColor: checked ? colors[`${color}9`] : colors.transparent,\n        },\n      },\n    },\n  }),\n  innerCircle: (color: Color, colorStep: ColorStep) => ({\n    borderRadius: radius.full,\n    variants: {\n      size: {\n        sm: {\n          width: getInnerCircleSize(16),\n          height: getInnerCircleSize(16),\n        },\n        md: {\n          width: getInnerCircleSize(20),\n          height: getInnerCircleSize(20),\n        },\n        lg: {\n          width: getInnerCircleSize(24),\n          height: getInnerCircleSize(24),\n        },\n      },\n      variant: {\n        ghost: {\n          backgroundColor: colors[`${color}${colorStep}`],\n        },\n        outline: {\n          backgroundColor: colors[`${color}${colorStep}`],\n        },\n        soft: {\n          backgroundColor: colors[`${color}${colorStep}`],\n        },\n        solid: {\n          backgroundColor: colors[`${color}${colorStep}`],\n        },\n      },\n    },\n  }),\n  outerCircleDisabled: {\n    borderColor: colors.neutral6,\n    backgroundColor: colors.neutral3,\n    variants: {\n      variant: {\n        ghost: {\n          backgroundColor: colors.transparent,\n        },\n      },\n    },\n  },\n  innerCircleDisabled: {\n    backgroundColor: colors.neutral8,\n  },\n}));\n\nfunction getInnerCircleSize(size: number) {\n  return Math.floor(size / 2.5);\n}\n\nexport {\n  RadioGroup,\n  RadioGroupItem,\n  RadioGroupIndicator,\n  useRadioGroup,\n  useRadioGroupItem,\n};\nexport type { RadioGroupProps, RadioGroupItemProps, RadioGroupIndicatorProps };\n",
  },
  {
    name: 'Accordion.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'useControllableState.ts',
        type: 'hook',
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
      {
        name: 'tokens.ts',
        type: 'style',
      },
    ],
    dependencies: ['react-native-reanimated'],
    code: "import * as React from 'react';\nimport {\n  GestureResponderEvent,\n  LayoutChangeEvent,\n  Pressable,\n  View,\n} from 'react-native';\nimport Animated, {\n  Easing,\n  FadeIn,\n  FadeOut,\n  ReduceMotion,\n  useAnimatedStyle,\n  useSharedValue,\n  withTiming,\n} from 'react-native-reanimated';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport { useControllableState } from '@/hooks/useControllableState';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\nimport type { Color } from '@/styles/tokens';\n\nconst animConfig = {\n  duration: 200,\n  easing: Easing.out(Easing.ease),\n  reduceMotion: ReduceMotion.System,\n} as const;\n\ntype AccordionColor = Color;\ntype AccordionVariant = 'soft';\n\ntype AccordionContextValue = {\n  type: 'single' | 'multiple';\n  value: string | string[];\n  onValueChange: (value: string | string[]) => void;\n  color: AccordionColor;\n  variant: AccordionVariant;\n  disabled?: boolean;\n};\n\nconst AccordionContext = React.createContext<AccordionContextValue | null>(\n  null,\n);\n\nconst useAccordion = () => {\n  const ctx = React.useContext(AccordionContext);\n  if (!ctx) {\n    throw new Error('useAccordion must be used within a <Accordion />');\n  }\n  return ctx;\n};\n\ntype ItemPosition = 'first' | 'middle' | 'last' | 'single';\n\ntype AccordionItemPositionContextValue = ItemPosition;\n\nconst AccordionItemPositionContext =\n  React.createContext<AccordionItemPositionContextValue | null>(null);\n\nconst useAccordionItemPosition = () => {\n  const ctx = React.useContext(AccordionItemPositionContext);\n  if (!ctx) {\n    throw new Error(\n      'useAccordionItemPosition must be used within a <AccordionItem />',\n    );\n  }\n  return ctx;\n};\n\ntype AccordionCommonProps<T extends React.ElementType> = PolymorphicProps<T> & {\n  color?: AccordionColor;\n  variant?: AccordionVariant;\n  disabled?: boolean;\n};\n\ntype AccordionSingleProps<T extends React.ElementType> =\n  AccordionCommonProps<T> & {\n    type?: 'single';\n    defaultValue?: string;\n    value?: string;\n    onValueChange?: (value: string) => void;\n  };\n\ntype AccordionMultipleProps<T extends React.ElementType> =\n  AccordionCommonProps<T> & {\n    type?: 'multiple';\n    defaultValue?: string[];\n    value?: string[];\n    onValueChange?: (value: string[]) => void;\n  };\n\ntype AccordionProps<T extends React.ElementType = typeof View> =\n  | AccordionSingleProps<T>\n  | AccordionMultipleProps<T>;\n\nconst Accordion = genericForwardRef(function Accordion<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    children,\n    type = 'multiple',\n    color = 'neutral',\n    variant = 'soft',\n    disabled,\n    defaultValue = [],\n    value: valueProp,\n    onValueChange: onValueChangeProp,\n    style,\n    ...restProps\n  }: AccordionProps<T>,\n  ref: React.ForwardedRef<T>,\n) {\n  const { styles } = useStyles(stylesheet);\n\n  const [value, setValue] = useControllableState<string | string[]>({\n    defaultValue,\n    controlledValue: valueProp,\n    onControlledChange: onValueChangeProp as\n      | ((value: string | string[]) => void)\n      | undefined,\n  });\n\n  const childrenArr = Array.isArray(children) ? children : [children];\n\n  const Comp = as || View;\n\n  return (\n    <AccordionContext.Provider\n      value={{\n        disabled,\n        type,\n        value,\n        color,\n        variant,\n        onValueChange: setValue,\n      }}\n    >\n      <Comp ref={ref} style={[styles.accordion, style]} {...restProps}>\n        {childrenArr.map((child, i) => {\n          return (\n            <AccordionItemPositionContext.Provider\n              key={i}\n              value={\n                childrenArr.length === 1\n                  ? 'single'\n                  : i === 0\n                    ? 'first'\n                    : i === childrenArr.length - 1\n                      ? 'last'\n                      : 'middle'\n              }\n            >\n              {child}\n            </AccordionItemPositionContext.Provider>\n          );\n        })}\n      </Comp>\n    </AccordionContext.Provider>\n  );\n});\n\ntype AccordionItemContextValue = {\n  value: string;\n  triggerId: string;\n  expanded: boolean;\n  disabled?: boolean;\n};\n\nconst AccordionItemContext =\n  React.createContext<AccordionItemContextValue | null>(null);\n\nconst useAccordionItem = () => {\n  const ctx = React.useContext(AccordionItemContext);\n  if (!ctx) {\n    throw new Error('useAccordionItem must be used within a <AccordionItem />');\n  }\n  return ctx;\n};\n\ntype AccordionItemProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T> & {\n    value: string;\n    disabled?: boolean;\n  };\n\nconst AccordionItem = genericForwardRef(function AccordionItem<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    disabled: disabledProp,\n    value,\n    style,\n    ...restProps\n  }: AccordionItemProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const {\n    value: rootValue,\n    type,\n    disabled: rootDisabled,\n    color,\n    variant,\n  } = useAccordion();\n  const position = useAccordionItemPosition();\n\n  const { styles } = useStyles(stylesheet, {\n    variant,\n    position,\n  });\n\n  // priority: itemProps > rootProps\n  const disabled = disabledProp ?? rootDisabled ?? false;\n\n  const rootSingleValue = rootValue as string;\n  const rootMultipleValue = rootValue as string[];\n  const expanded =\n    type === 'single'\n      ? rootSingleValue === value\n      : rootMultipleValue.includes(value);\n\n  const triggerId = React.useId();\n\n  const Comp = as || View;\n\n  return (\n    <AccordionItemContext.Provider\n      value={{ expanded, disabled, triggerId, value }}\n    >\n      <Comp\n        ref={ref}\n        style={[styles.accordionItem(color), style]}\n        {...restProps}\n      />\n    </AccordionItemContext.Provider>\n  );\n});\n\ntype AccordionTriggerProps<T extends React.ElementType = typeof Pressable> =\n  Omit<PolymorphicProps<T>, 'nativeID' | 'children'> & {\n    children?:\n      | React.ReactNode\n      | ((state: { disabled: boolean; expanded: boolean }) => React.ReactNode);\n  };\n\nconst AccordionTrigger = genericForwardRef(function AccordionTrigger<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  {\n    as,\n    children,\n    accessibilityState,\n    disabled: disabledProp,\n    onPress: onPressProp,\n    style: styleProp,\n    ...restProps\n  }: AccordionTriggerProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const {\n    type,\n    color,\n    variant,\n    value: rootValue,\n    onValueChange,\n  } = useAccordion();\n  const {\n    expanded,\n    disabled: itemDisabled,\n    triggerId,\n    value: itemValue,\n  } = useAccordionItem();\n\n  const disabled = itemDisabled ?? disabledProp ?? false;\n\n  const { styles } = useStyles(stylesheet, {\n    variant,\n  });\n\n  const onPress = React.useCallback(\n    (e: GestureResponderEvent) => {\n      if (type === 'single') {\n        onValueChange(expanded ? '' : itemValue);\n      } else {\n        const rootMultipleValue = rootValue as string[];\n        onValueChange(\n          expanded\n            ? rootMultipleValue.filter((v) => v !== itemValue)\n            : [...rootMultipleValue, itemValue],\n        );\n      }\n      onPressProp?.(e);\n    },\n    [type, expanded, itemValue, rootValue, onPressProp, onValueChange],\n  );\n\n  const Comp = as || Pressable;\n\n  return (\n    <View accessibilityRole=\"header\">\n      <Comp\n        ref={ref}\n        nativeID={triggerId}\n        accessibilityRole=\"button\"\n        accessibilityState={{\n          disabled,\n          expanded,\n          ...accessibilityState,\n        }}\n        disabled={disabled}\n        onPress={onPress}\n        style={(state) => [\n          styles.accordionTrigger(state.pressed, color),\n          typeof styleProp === 'function' ? styleProp(state) : styleProp,\n        ]}\n        {...restProps}\n      >\n        {typeof children === 'function'\n          ? children({ disabled, expanded })\n          : children}\n      </Comp>\n    </View>\n  );\n});\n\ntype AccordionIndicatorProps<\n  T extends React.ElementType = typeof Animated.View,\n> = PolymorphicProps<T> & {\n  transition?: 'rotate' | 'flip';\n};\n\n/**\n * It helps to animate trigger indicator(e.g. icon).\n */\nconst AccordionIndicator = genericForwardRef(function AccordionIndicator<\n  T extends React.ElementType<\n    React.ComponentPropsWithoutRef<typeof Animated.View>\n  >,\n>(\n  { transition = 'rotate', style, ...restProps }: AccordionIndicatorProps<T>,\n  ref: React.ForwardedRef<Animated.View>,\n) {\n  const { expanded } = useAccordionItem();\n\n  const animatedStyle = useAnimatedStyle(() => {\n    if (transition === 'flip') {\n      // TODO: improve flip animation\n      return {\n        transform: [\n          {\n            rotateY: expanded\n              ? withTiming('180deg', animConfig)\n              : withTiming('0deg', animConfig),\n          },\n        ],\n      };\n    }\n    return {\n      transform: [\n        {\n          rotate: expanded\n            ? withTiming('180deg', animConfig)\n            : withTiming('0deg', animConfig),\n        },\n      ],\n    };\n  });\n\n  return (\n    <Animated.View ref={ref} style={[animatedStyle, style]} {...restProps} />\n  );\n});\n\ntype AccordionContentProps<T extends React.ElementType = typeof View> = Omit<\n  PolymorphicProps<T>,\n  'accessibilityLabelledBy'\n>;\n\nconst AccordionContent = genericForwardRef(function AccordionContent<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    accessibilityRole = 'summary',\n    style,\n    ...restProps\n  }: AccordionContentProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { variant } = useAccordion();\n  const { triggerId, expanded } = useAccordionItem();\n\n  const { styles } = useStyles(stylesheet, {\n    variant,\n  });\n\n  const height = useSharedValue(0);\n\n  const animatedStyle = useAnimatedStyle(() => {\n    return {\n      height: expanded\n        ? withTiming(height.value, animConfig)\n        : withTiming(0, animConfig),\n      overflow: 'hidden',\n    };\n  });\n\n  const onLayout = React.useCallback(\n    (e: LayoutChangeEvent) => {\n      height.value = e.nativeEvent.layout.height;\n    },\n    [height],\n  );\n\n  const Comp = as || View;\n\n  return (\n    <Animated.View style={animatedStyle}>\n      {expanded && (\n        <Animated.View\n          entering={FadeIn.duration(animConfig.duration)\n            .easing(animConfig.easing)\n            .reduceMotion(animConfig.reduceMotion)}\n          exiting={FadeOut.duration(animConfig.duration)\n            .easing(animConfig.easing)\n            .reduceMotion(animConfig.reduceMotion)}\n          onLayout={onLayout}\n          style={styles.accordionContentContainer}\n        >\n          <Comp\n            ref={ref}\n            accessibilityRole={accessibilityRole}\n            accessibilityLabelledBy={triggerId}\n            style={[styles.accordionContent, style]}\n            {...restProps}\n          />\n        </Animated.View>\n      )}\n    </Animated.View>\n  );\n});\n\nconst stylesheet = createStyleSheet(({ colors, radius, space }) => ({\n  accordion: {\n    overflow: 'hidden',\n    gap: space[2],\n  },\n  accordionItem: (color: Color) => ({\n    borderCurve: 'continuous',\n    overflow: 'hidden',\n    variants: {\n      variant: {\n        soft: {\n          backgroundColor: colors[`${color}3`],\n        },\n      },\n      position: {\n        single: {\n          borderRadius: radius.md,\n        },\n        first: {\n          borderTopStartRadius: radius.md,\n          borderTopEndRadius: radius.md,\n          borderBottomStartRadius: radius.xs,\n          borderBottomEndRadius: radius.xs,\n        },\n        last: {\n          borderTopStartRadius: radius.xs,\n          borderTopEndRadius: radius.xs,\n          borderBottomStartRadius: radius.md,\n          borderBottomEndRadius: radius.md,\n        },\n        middle: {\n          borderRadius: radius.xs,\n        },\n      },\n    },\n  }),\n  accordionTrigger: (pressed: boolean, color: Color) => ({\n    width: '100%',\n    flexDirection: 'row',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    gap: space[12],\n    minHeight: 52,\n    height: 'auto',\n    paddingHorizontal: space[20],\n    variants: {\n      variant: {\n        soft: {\n          backgroundColor: pressed ? colors[`${color}4`] : colors[`${color}3`],\n        },\n      },\n    },\n  }),\n  accordionContentContainer: {\n    position: 'absolute',\n  },\n  accordionContent: {\n    paddingBottom: space[16],\n    paddingHorizontal: space[16],\n  },\n}));\n\nexport {\n  Accordion,\n  AccordionItem,\n  AccordionTrigger,\n  AccordionIndicator,\n  AccordionContent,\n  useAccordion,\n  useAccordionItem,\n};\nexport type {\n  AccordionProps,\n  AccordionItemProps,\n  AccordionTriggerProps,\n  AccordionIndicatorProps,\n  AccordionContentProps,\n};\n",
  },
  {
    name: 'Alert.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'Text.tsx',
        type: 'component',
        registryDependencies: [
          {
            name: 'genericForwardRef.ts',
            type: 'utility',
          },
          {
            name: 'components.ts',
            type: 'type',
          },
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'Icon.tsx',
        type: 'component',
        dependencies: [
          '@react-native-vector-icons/common',
          '@react-native-vector-icons/ionicons',
        ],
        devDependencies: ['@types/react-native-vector-icons'],
        registryDependencies: [
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
      {
        name: 'tokens.ts',
        type: 'style',
      },
    ],
    code: "import * as React from 'react';\nimport { View } from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport { Text, TextProps } from './Text';\nimport { Icon, IconProps } from './Icon';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\nimport type { Color } from '@/styles/tokens';\n\ntype AlertColor = Color;\ntype AlertSize = 'sm' | 'md' | 'lg';\ntype AlertVariant = 'soft' | 'outline';\n\ntype AlertContextValue = {\n  color: AlertColor;\n  size: AlertSize;\n  variant: AlertVariant;\n  highContrast: boolean;\n};\n\nconst AlertContext = React.createContext<AlertContextValue | null>(null);\n\nconst useAlert = () => {\n  const ctx = React.useContext(AlertContext);\n  if (!ctx) {\n    throw new Error('useAlert must be used within a <Alert />');\n  }\n  return ctx;\n};\n\ntype AlertProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T> & {\n    highContrast?: boolean;\n    size?: AlertSize;\n    variant?: AlertVariant;\n    color?: AlertColor;\n  };\n\nconst Alert = genericForwardRef(function Alert<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    color = 'primary',\n    size = 'md',\n    variant = 'soft',\n    highContrast = false,\n    style,\n    ...restProps\n  }: AlertProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { styles } = useStyles(stylesheet, {\n    size,\n    variant,\n  });\n\n  const Comp = as || View;\n\n  return (\n    <AlertContext.Provider value={{ color, highContrast, size, variant }}>\n      <Comp\n        ref={ref}\n        accessibilityRole=\"alert\"\n        style={[styles.alert(color), style]}\n        {...restProps}\n      />\n    </AlertContext.Provider>\n  );\n});\n\nconst titleVariantMap: Record<AlertSize, TextProps['variant']> = {\n  sm: 'labelSm',\n  md: 'labelMd',\n  lg: 'labelLg',\n};\n\ntype AlertTitleProps<T extends React.ElementType = typeof Text> = TextProps<T>;\n\nconst AlertTitle = genericForwardRef(function AlertTitle<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Text>>,\n>(props: AlertTitleProps<T>, ref: React.ForwardedRef<T>) {\n  const { color, highContrast, size } = useAlert();\n  return (\n    <Text\n      ref={ref}\n      color={color}\n      variant={titleVariantMap[size]}\n      highContrast={highContrast}\n      {...props}\n    />\n  );\n});\n\nconst descriptionVariantMap: Record<AlertSize, TextProps['variant']> = {\n  sm: 'bodyXs',\n  md: 'bodySm',\n  lg: 'bodyMd',\n};\n\ntype AlertDescriptionProps<T extends React.ElementType = typeof Text> =\n  TextProps<T>;\n\nconst AlertDescription = genericForwardRef(function AlertDescription<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Text>>,\n>(props: AlertDescriptionProps<T>, ref: React.ForwardedRef<T>) {\n  const { color, highContrast, size } = useAlert();\n\n  return (\n    <Text\n      ref={ref}\n      color={color}\n      variant={descriptionVariantMap[size]}\n      highContrast={highContrast}\n      {...props}\n    />\n  );\n});\n\ntype AlertIconProps = IconProps;\n\nconst iconSizeMap: Record<AlertSize, IconProps['size']> = {\n  sm: '2xl',\n  md: '3xl',\n  lg: '4xl',\n};\n\nconst AlertIcon = React.forwardRef<\n  React.ElementRef<typeof Icon>,\n  AlertIconProps\n>(function AlertIcon(props: AlertIconProps, ref) {\n  const { color, highContrast, size } = useAlert();\n  return (\n    <Icon\n      ref={ref}\n      color={color}\n      size={iconSizeMap[size]}\n      highContrast={highContrast}\n      {...props}\n    />\n  );\n});\n\nconst stylesheet = createStyleSheet(({ colors, radius, space }) => ({\n  alert: (color: Color) => ({\n    width: '100%',\n    borderCurve: 'continuous',\n    variants: {\n      size: {\n        sm: {\n          gap: space[4],\n          padding: space[16],\n          borderRadius: radius.md,\n        },\n        md: {\n          gap: space[8],\n          padding: space[20],\n          borderRadius: radius.lg,\n        },\n        lg: {\n          gap: space[12],\n          padding: space[24],\n          borderRadius: radius.lg,\n        },\n      },\n      variant: {\n        soft: {\n          backgroundColor: colors[`${color}3`],\n        },\n        outline: {\n          backgroundColor: colors.transparent,\n          borderWidth: 1,\n          borderColor: colors[`${color}7`],\n        },\n      },\n    },\n  }),\n}));\n\nexport { Alert, AlertTitle, AlertIcon, AlertDescription, useAlert };\nexport type {\n  AlertProps,\n  AlertTitleProps,\n  AlertIconProps,\n  AlertDescriptionProps,\n};\n",
  },
  {
    name: 'Avatar.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'Text.tsx',
        type: 'component',
        registryDependencies: [
          {
            name: 'genericForwardRef.ts',
            type: 'utility',
          },
          {
            name: 'components.ts',
            type: 'type',
          },
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'Icon.tsx',
        type: 'component',
        dependencies: [
          '@react-native-vector-icons/common',
          '@react-native-vector-icons/ionicons',
        ],
        devDependencies: ['@types/react-native-vector-icons'],
        registryDependencies: [
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
      {
        name: 'tokens.ts',
        type: 'style',
      },
    ],
    code: "import * as React from 'react';\nimport {\n  Image,\n  ImageErrorEventData,\n  ImageLoadEventData,\n  NativeSyntheticEvent,\n  View,\n} from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport { Text, TextProps } from './Text';\nimport { Icon, IconProps } from './Icon';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\nimport type { Color, ColorStep } from '@/styles/tokens';\n\ntype AvatarColor = Color;\ntype AvatarVariant = 'soft' | 'solid';\ntype AvatarSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl';\ntype ImageLoadingStatus = 'idle' | 'loading' | 'loaded' | 'error';\n\ntype AvatarContextValue = {\n  color: AvatarColor;\n  variant: AvatarVariant;\n  size: AvatarSize;\n  imageLoadingStatus: ImageLoadingStatus;\n  onLoadingStatusChange: (status: ImageLoadingStatus) => void;\n};\n\nconst AvatarContext = React.createContext<AvatarContextValue | null>(null);\n\nconst useAvatar = () => {\n  const ctx = React.useContext(AvatarContext);\n  if (!ctx) {\n    throw new Error('useAvatar must be used within a <Avatar />');\n  }\n  return ctx;\n};\n\ntype AvatarProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T> & {\n    color?: AvatarColor;\n    variant?: AvatarVariant;\n    size?: AvatarSize;\n  };\n\nconst Avatar = genericForwardRef(function Avatar<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    color = 'primary',\n    size = 'md',\n    variant = 'soft',\n    style,\n    ...restProps\n  }: AvatarProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const [imageLoadingStatus, setImageLoadingStatus] =\n    React.useState<ImageLoadingStatus>('idle');\n\n  const { styles } = useStyles(stylesheet, {\n    size,\n    variant,\n  });\n\n  const onLoadingStatusChange = React.useCallback(\n    (status: ImageLoadingStatus) => {\n      setImageLoadingStatus(status);\n    },\n    [],\n  );\n\n  const Comp = as || View;\n\n  return (\n    <AvatarContext.Provider\n      value={{\n        color,\n        variant,\n        size,\n        imageLoadingStatus,\n        onLoadingStatusChange,\n      }}\n    >\n      <Comp ref={ref} style={[styles.image, style]} {...restProps} />\n    </AvatarContext.Provider>\n  );\n});\n\ntype AvatarImageProps<T extends React.ElementType = typeof Image> =\n  PolymorphicProps<T>;\n\nconst AvatarImage = genericForwardRef(function AvatarImage<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Image>>,\n>(\n  {\n    as,\n    onError: onErrorProp,\n    onLoad: onLoadProp,\n    onLoadStart: onLoadStartProp,\n    style,\n    ...restProps\n  }: AvatarImageProps<T>,\n  ref: React.ForwardedRef<Image>,\n) {\n  const { onLoadingStatusChange, size, variant } = useAvatar();\n\n  const { styles } = useStyles(stylesheet, {\n    size,\n    variant,\n  });\n\n  React.useEffect(() => {\n    return () => {\n      onLoadingStatusChange('idle');\n    };\n  }, [onLoadingStatusChange]);\n\n  const onLoadStart = React.useCallback(() => {\n    onLoadingStatusChange('loading');\n    onLoadStartProp?.();\n  }, [onLoadStartProp, onLoadingStatusChange]);\n\n  const onLoad = React.useCallback(\n    (e: NativeSyntheticEvent<ImageLoadEventData>) => {\n      onLoadingStatusChange('loaded');\n      onLoadProp?.(e);\n    },\n    [onLoadProp, onLoadingStatusChange],\n  );\n\n  const onError = React.useCallback(\n    (e: NativeSyntheticEvent<ImageErrorEventData>) => {\n      onLoadingStatusChange('error');\n      onErrorProp?.(e);\n    },\n    [onErrorProp, onLoadingStatusChange],\n  );\n\n  const Comp = as || Image;\n\n  return (\n    <Comp\n      ref={ref}\n      onError={onError}\n      onLoad={onLoad}\n      onLoadStart={onLoadStart}\n      style={[styles.image, style]}\n      {...restProps}\n    />\n  );\n});\n\ntype AvatarFallbackProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T> & {\n    delayMs?: number;\n  };\n\nconst AvatarFallback = genericForwardRef(function AvatarFallback<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  { as, delayMs, style, ...restProps }: AvatarFallbackProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { imageLoadingStatus, color, size, variant } = useAvatar();\n\n  const [canRender, setCanRender] = React.useState(delayMs === undefined);\n\n  const { styles } = useStyles(stylesheet, {\n    size,\n    variant,\n  });\n\n  React.useEffect(() => {\n    let timerId: ReturnType<typeof setTimeout>;\n    if (delayMs !== undefined) {\n      timerId = setTimeout(() => setCanRender(true), delayMs);\n    }\n    return () => clearTimeout(timerId);\n  }, [delayMs]);\n\n  const Comp = as || View;\n\n  return canRender && imageLoadingStatus !== 'loaded' ? (\n    <Comp\n      ref={ref}\n      style={[styles.image, styles.fallback(color), style]}\n      {...restProps}\n    />\n  ) : null;\n});\n\nconst textVariantsMap: Record<AvatarSize, TextProps['variant']> = {\n  xs: 'labelXs',\n  sm: 'labelSm',\n  md: 'labelSm',\n  lg: 'headingXs',\n  xl: 'headingSm',\n  '2xl': 'headingMd',\n};\n\ntype AvatarTextProps<T extends React.ElementType = typeof Text> = TextProps<T>;\n\nconst AvatarText = genericForwardRef(function AvatarText<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Text>>,\n>(props: AvatarTextProps<T>, ref: React.ForwardedRef<T>) {\n  const { color, size, variant } = useAvatar();\n\n  const colorStep: ColorStep = variant === 'solid' ? 'Contrast' : '11';\n\n  return (\n    <Text\n      ref={ref}\n      color={color}\n      colorStep={colorStep}\n      variant={textVariantsMap[size]}\n      {...props}\n    />\n  );\n});\n\nconst iconSizeMap: Record<AvatarSize, IconProps['size']> = {\n  xs: 'xs',\n  sm: 'sm',\n  md: 'md',\n  lg: 'xl',\n  xl: '3xl',\n  '2xl': '5xl',\n};\n\ntype AvatarIconProps = IconProps;\n\nconst AvatarIcon = React.forwardRef<\n  React.ElementRef<typeof Icon>,\n  AvatarIconProps\n>((props: AvatarIconProps, forwardedRef) => {\n  const { color, size, variant } = useAvatar();\n\n  const colorStep: ColorStep = variant === 'solid' ? 'Contrast' : '11';\n\n  return (\n    <Icon\n      ref={forwardedRef}\n      color={color}\n      colorStep={colorStep}\n      size={iconSizeMap[size]}\n      {...props}\n    />\n  );\n});\n\nAvatarIcon.displayName = 'AvatarIcon';\n\nconst stylesheet = createStyleSheet(({ colors, radius }) => ({\n  image: {\n    position: 'relative',\n    borderRadius: radius.full,\n    overflow: 'hidden',\n    variants: {\n      size: {\n        xs: {\n          width: 28,\n          height: 28,\n        },\n        sm: {\n          width: 36,\n          height: 36,\n        },\n        md: {\n          width: 44,\n          height: 44,\n        },\n        lg: {\n          width: 52,\n          height: 52,\n        },\n        xl: {\n          width: 64,\n          height: 64,\n        },\n        '2xl': {\n          width: 80,\n          height: 80,\n        },\n      },\n    },\n  },\n  fallback: (color: Color) => ({\n    position: 'absolute',\n    justifyContent: 'center',\n    alignItems: 'center',\n    variants: {\n      variant: {\n        soft: {\n          backgroundColor: colors[`${color}3`],\n        },\n        solid: {\n          backgroundColor: colors[`${color}9`],\n        },\n      },\n    },\n  }),\n}));\n\nexport {\n  Avatar,\n  AvatarImage,\n  AvatarFallback,\n  AvatarText,\n  AvatarIcon,\n  useAvatar,\n};\nexport type {\n  AvatarProps,\n  AvatarImageProps,\n  AvatarFallbackProps,\n  AvatarTextProps,\n  AvatarIconProps,\n};\n",
  },
  {
    name: 'Badge.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'Text.tsx',
        type: 'component',
        registryDependencies: [
          {
            name: 'genericForwardRef.ts',
            type: 'utility',
          },
          {
            name: 'components.ts',
            type: 'type',
          },
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'Icon.tsx',
        type: 'component',
        dependencies: [
          '@react-native-vector-icons/common',
          '@react-native-vector-icons/ionicons',
        ],
        devDependencies: ['@types/react-native-vector-icons'],
        registryDependencies: [
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
      {
        name: 'tokens.ts',
        type: 'style',
      },
    ],
    code: "import * as React from 'react';\nimport { View } from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport { Icon, IconProps } from './Icon';\nimport { Text, TextProps } from './Text';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\nimport type { Color, ColorStep } from '@/styles/tokens';\n\ntype BadgeColor = Color;\ntype BadgeSize = 'sm' | 'md' | 'lg';\ntype BadgeVariant = 'solid' | 'soft' | 'outline' | 'surface';\n\ntype BadgeContextValue = {\n  color: BadgeColor;\n  size: BadgeSize;\n  variant: BadgeVariant;\n  highContrast: boolean;\n  disabled: boolean;\n  iconOnly: boolean;\n};\n\nconst BadgeContext = React.createContext<BadgeContextValue | null>(null);\n\nconst useBadge = () => {\n  const ctx = React.useContext(BadgeContext);\n  if (!ctx) {\n    throw new Error('useBadge must be used within a <Badge />');\n  }\n  return ctx;\n};\n\ntype BadgeProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T> & {\n    color?: BadgeColor;\n    size?: BadgeSize;\n    variant?: BadgeVariant;\n    highContrast?: boolean;\n    disabled?: boolean;\n    iconOnly?: boolean;\n  };\n\nconst Badge = genericForwardRef(function Badge<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    color = 'primary',\n    size = 'md',\n    variant = 'solid',\n    highContrast = false,\n    disabled = false,\n    iconOnly = false,\n    style: styleProp,\n    ...restProps\n  }: BadgeProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { styles } = useStyles(stylesheet, {\n    size,\n    variant,\n  });\n\n  const Comp = as || View;\n\n  return (\n    <BadgeContext.Provider\n      value={{\n        color,\n        size,\n        variant,\n        highContrast,\n        disabled,\n        iconOnly,\n      }}\n    >\n      <Comp\n        ref={ref}\n        style={[\n          styles.badge(color, iconOnly),\n          disabled && styles.badgeDisabled,\n          styleProp,\n        ]}\n        {...restProps}\n      />\n    </BadgeContext.Provider>\n  );\n});\n\nconst textFontSizeMap: Record<\n  NonNullable<BadgeProps['size']>,\n  TextProps['fontSize']\n> = {\n  sm: 11,\n  md: 12,\n  lg: 14,\n};\n\ntype BadgeTextProps<T extends React.ElementType = typeof Text> = TextProps<T>;\n\nconst BadgeText = genericForwardRef(function BadgeText<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Text>>,\n>(props: BadgeTextProps<T>, ref: React.ForwardedRef<T>) {\n  const { color, variant, highContrast, size, disabled } = useBadge();\n\n  const colorStep: ColorStep =\n    variant === 'solid' ? 'Contrast' : highContrast ? '12' : '11';\n\n  return (\n    <Text\n      ref={ref}\n      color={color}\n      colorStep={colorStep}\n      fontSize={textFontSizeMap[size]}\n      fontFamily=\"interMedium\"\n      disabled={disabled}\n      inherit\n      {...props}\n    />\n  );\n});\n\nconst iconSizeMap: Record<\n  NonNullable<BadgeProps['size']>,\n  IconProps['size']\n> = {\n  sm: '2xs',\n  md: 'xs',\n  lg: 'sm',\n};\n\ntype BadgeIconProps = IconProps;\n\nconst BadgeIcon = React.forwardRef<\n  React.ElementRef<typeof Icon>,\n  BadgeIconProps\n>(function BadgeIcon(props, ref) {\n  const { color, size, variant, highContrast, disabled } = useBadge();\n\n  const colorStep: ColorStep =\n    variant === 'solid' ? 'Contrast' : highContrast ? '12' : '11';\n\n  return (\n    <Icon\n      ref={ref}\n      color={color}\n      colorStep={colorStep}\n      size={iconSizeMap[size]}\n      highContrast={highContrast}\n      disabled={disabled}\n      {...props}\n    />\n  );\n});\n\nconst stylesheet = createStyleSheet(({ colors, radius, space }) => ({\n  badge: (color: Color, iconOnly: boolean) => ({\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n    borderRadius: radius.full,\n    borderCurve: 'continuous',\n    variants: {\n      size: {\n        sm: {\n          width: iconOnly ? 20 : 'auto',\n          height: 20,\n          gap: space[2],\n          paddingHorizontal: iconOnly ? 0 : space[8],\n        },\n        md: {\n          width: iconOnly ? 24 : 'auto',\n          height: 24,\n          gap: space[4],\n          paddingHorizontal: iconOnly ? 0 : space[10],\n        },\n        lg: {\n          width: iconOnly ? 28 : 'auto',\n          height: 28,\n          gap: space[4],\n          paddingHorizontal: iconOnly ? 0 : space[12],\n        },\n      },\n      variant: {\n        solid: {\n          backgroundColor: colors[`${color}9`],\n        },\n        soft: {\n          backgroundColor: colors[`${color}3`],\n        },\n        outline: {\n          borderWidth: 1,\n          backgroundColor: colors.transparent,\n          borderColor: colors[`${color}7`],\n        },\n        surface: {\n          borderWidth: 1,\n          backgroundColor: colors[`${color}3`],\n          borderColor: colors[`${color}7`],\n        },\n      },\n    },\n  }),\n  badgeDisabled: {\n    backgroundColor: colors.neutral3,\n    borderColor: colors.neutral6,\n    variants: {\n      variant: {\n        solid: {},\n        soft: {},\n        outline: {\n          borderWidth: 1,\n          backgroundColor: colors.transparent,\n        },\n        surface: {\n          borderWidth: 1,\n        },\n      },\n    },\n  },\n}));\n\nexport { Badge, BadgeText, BadgeIcon, useBadge };\nexport type { BadgeProps, BadgeTextProps, BadgeIconProps };\n",
  },
  {
    name: 'Button.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'Text.tsx',
        type: 'component',
        registryDependencies: [
          {
            name: 'genericForwardRef.ts',
            type: 'utility',
          },
          {
            name: 'components.ts',
            type: 'type',
          },
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'Icon.tsx',
        type: 'component',
        dependencies: [
          '@react-native-vector-icons/common',
          '@react-native-vector-icons/ionicons',
        ],
        devDependencies: ['@types/react-native-vector-icons'],
        registryDependencies: [
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
      {
        name: 'tokens.ts',
        type: 'style',
      },
    ],
    code: "import * as React from 'react';\nimport { Pressable, View } from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport { Icon, IconProps } from './Icon';\nimport { Text, TextProps } from './Text';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\nimport type { Color, ColorStep } from '@/styles/tokens';\n\ntype ButtonColor = Color;\ntype ButtonSize = 'xs' | 'sm' | 'md' | 'lg';\ntype ButtonVariant = 'solid' | 'soft' | 'outline' | 'ghost' | 'plain';\n\ntype ButtonContextValue = {\n  color: ButtonColor;\n  size: ButtonSize;\n  variant: ButtonVariant;\n  highContrast: boolean;\n  disabled: boolean;\n  iconOnly: boolean;\n};\n\nconst ButtonContext = React.createContext<ButtonContextValue | null>(null);\n\nButtonContext.displayName = 'ButtonContext';\n\nconst useButton = () => {\n  const ctx = React.useContext(ButtonContext);\n  if (!ctx) {\n    throw new Error('useButton must be used within a <Button />');\n  }\n  return ctx;\n};\n\ntype ButtonProps<T extends React.ElementType = typeof Pressable> =\n  PolymorphicProps<T> & {\n    color?: ButtonColor;\n    size?: ButtonSize;\n    variant?: ButtonVariant;\n    highContrast?: boolean;\n    fill?: boolean;\n    iconOnly?: boolean;\n  };\n\nconst Button = genericForwardRef(function Button<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  {\n    as,\n    accessibilityState,\n    color = 'primary',\n    size = 'md',\n    variant = 'solid',\n    disabled: disabledProp,\n    fill = false,\n    highContrast = false,\n    iconOnly = false,\n    style: styleProp,\n    ...restProps\n  }: ButtonProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { styles } = useStyles(stylesheet, {\n    size,\n    variant,\n    fill,\n  });\n\n  const disabled = disabledProp ?? false;\n\n  const Comp = as || Pressable;\n\n  return (\n    <ButtonContext.Provider\n      value={{\n        color,\n        size,\n        variant,\n        highContrast,\n        disabled,\n        iconOnly,\n      }}\n    >\n      <Comp\n        ref={ref}\n        accessibilityRole=\"button\"\n        accessibilityState={{\n          disabled,\n          ...accessibilityState,\n        }}\n        disabled={disabled}\n        style={(state) => [\n          styles.button(color, state.pressed, iconOnly),\n          disabled && styles.disabledButton,\n          typeof styleProp === 'function' ? styleProp(state) : styleProp,\n        ]}\n        {...restProps}\n      />\n    </ButtonContext.Provider>\n  );\n});\n\nconst textVariantMap: Record<\n  NonNullable<ButtonProps['size']>,\n  TextProps['variant']\n> = {\n  xs: 'labelXs',\n  sm: 'labelSm',\n  md: 'labelMd',\n  lg: 'labelLg',\n};\n\ntype ButtonTextProps<T extends React.ElementType = typeof Text> = TextProps<T>;\n\nconst ButtonText = genericForwardRef(function ButtonText<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Text>>,\n>(props: ButtonTextProps<T>, ref: React.ForwardedRef<T>) {\n  const { color, size, variant, highContrast, disabled } = useButton();\n\n  const colorStep: ColorStep =\n    variant === 'solid' ? 'Contrast' : highContrast ? '12' : '11';\n\n  return (\n    <Text\n      ref={ref}\n      color={color}\n      colorStep={colorStep}\n      variant={textVariantMap[size]}\n      highContrast={highContrast}\n      disabled={disabled}\n      {...props}\n    />\n  );\n});\n\nconst iconSizeMap: Record<\n  NonNullable<ButtonProps['size']>,\n  IconProps['size']\n> = {\n  xs: 'sm',\n  sm: 'md',\n  md: 'lg',\n  lg: 'xl',\n};\nconst iconOnlySizeMap: Record<\n  NonNullable<ButtonProps['size']>,\n  IconProps['size']\n> = {\n  xs: 'md',\n  sm: 'lg',\n  md: 'xl',\n  lg: '2xl',\n};\n\ntype ButtonIconProps = IconProps;\n\nconst ButtonIcon = React.forwardRef<\n  React.ElementRef<typeof Icon>,\n  ButtonIconProps\n>(function ButtonIcon(props: ButtonIconProps, ref) {\n  const { color, size, variant, highContrast, disabled, iconOnly } =\n    useButton();\n\n  const colorStep: ColorStep =\n    variant === 'solid' ? 'Contrast' : highContrast ? '12' : '11';\n\n  return (\n    <Icon\n      ref={ref}\n      color={color}\n      colorStep={colorStep}\n      size={iconOnly ? iconOnlySizeMap[size] : iconSizeMap[size]}\n      highContrast={highContrast}\n      disabled={disabled}\n      {...props}\n    />\n  );\n});\n\nconst stylesheet = createStyleSheet(({ colors, radius, space }) => ({\n  button: (color: Color, pressed: boolean, iconOnly: boolean) => ({\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderRadius: radius.md,\n    borderCurve: 'continuous',\n    variants: {\n      size: {\n        xs: {\n          width: iconOnly ? 28 : 'auto',\n          height: 28,\n          paddingHorizontal: iconOnly ? 0 : space[8],\n          gap: space[4],\n        },\n        sm: {\n          width: iconOnly ? 36 : 'auto',\n          height: 36,\n          paddingHorizontal: iconOnly ? 0 : space[12],\n          gap: space[6],\n        },\n        md: {\n          width: iconOnly ? 44 : 'auto',\n          height: 44,\n          paddingHorizontal: iconOnly ? 0 : space[16],\n          gap: space[8],\n        },\n        lg: {\n          width: iconOnly ? 52 : 'auto',\n          height: 52,\n          paddingHorizontal: iconOnly ? 0 : space[20],\n          gap: space[12],\n        },\n      },\n      variant: {\n        solid: {\n          backgroundColor: pressed ? colors[`${color}10`] : colors[`${color}9`],\n        },\n        soft: {\n          backgroundColor: pressed ? colors[`${color}4`] : colors[`${color}3`],\n        },\n        outline: {\n          borderWidth: 1,\n          backgroundColor: pressed ? colors[`${color}3`] : colors.transparent,\n          borderColor: pressed ? colors[`${color}8`] : colors[`${color}7`],\n        },\n        ghost: {\n          backgroundColor: pressed ? colors[`${color}3`] : colors.transparent,\n        },\n        plain: {\n          opacity: pressed ? 0.5 : 1,\n          backgroundColor: colors.transparent,\n        },\n      },\n      fill: {\n        true: {\n          width: '100%',\n          flexShrink: 1,\n        },\n        false: {},\n      },\n    },\n  }),\n  disabledButton: {\n    borderColor: colors.neutral6,\n    variants: {\n      variant: {\n        solid: {\n          backgroundColor: colors.neutral3,\n        },\n        soft: {\n          backgroundColor: colors.neutral3,\n        },\n        outline: {\n          borderWidth: 1,\n          backgroundColor: colors.transparent,\n        },\n        ghost: {\n          backgroundColor: colors.transparent,\n        },\n        plain: {\n          backgroundColor: colors.transparent,\n        },\n      },\n    },\n  },\n}));\n\nexport { Button, ButtonText, ButtonIcon, useButton };\nexport type { ButtonProps, ButtonTextProps, ButtonIconProps };\n",
  },
  {
    name: 'Checkbox.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'Icon.tsx',
        type: 'component',
        dependencies: [
          '@react-native-vector-icons/common',
          '@react-native-vector-icons/ionicons',
        ],
        devDependencies: ['@types/react-native-vector-icons'],
        registryDependencies: [
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'useControllableState.ts',
        type: 'hook',
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
      {
        name: 'tokens.ts',
        type: 'style',
      },
    ],
    code: "import * as React from 'react';\nimport { GestureResponderEvent, Pressable, View } from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport { Icon, IconProps } from './Icon';\nimport { useControllableState } from '@/hooks/useControllableState';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\nimport type { Color, ColorStep } from '@/styles/tokens';\n\ntype CheckboxColor = Color;\ntype CheckboxSize = 'sm' | 'md' | 'lg';\ntype CheckboxVariant = 'solid' | 'soft' | 'outline' | 'ghost';\n\ntype CheckboxContextValue = {\n  checked: boolean;\n  disabled: boolean;\n  color: CheckboxColor;\n  size: CheckboxSize;\n  variant: CheckboxVariant;\n  highContrast: boolean;\n};\n\nconst CheckboxContext = React.createContext<CheckboxContextValue | null>(null);\n\nconst useCheckbox = () => {\n  const ctx = React.useContext(CheckboxContext);\n  if (!ctx) {\n    throw new Error('useCheckbox must be used within a <Checkbox />');\n  }\n  return ctx;\n};\n\ntype CheckboxProps<T extends React.ElementType = typeof Pressable> =\n  PolymorphicProps<T> & {\n    checked?: boolean;\n    defaultChecked?: boolean;\n    onCheckedChange?: (checked: boolean) => void;\n    color?: CheckboxColor;\n    size?: CheckboxSize;\n    variant?: CheckboxVariant;\n    highContrast?: boolean;\n  };\n\nconst Checkbox = genericForwardRef(function Checkbox<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  {\n    as,\n    accessibilityState,\n    checked: checkedProp,\n    defaultChecked,\n    onCheckedChange,\n    onPress: onPressProp,\n    disabled,\n    color = 'primary',\n    size = 'md',\n    variant = 'solid',\n    highContrast = false,\n    ...restProps\n  }: CheckboxProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const [checked, setChecked] = useControllableState({\n    defaultValue: defaultChecked ?? false,\n    controlledValue: checkedProp,\n    onControlledChange: onCheckedChange,\n  });\n\n  const onPress = React.useCallback(\n    (e: GestureResponderEvent) => {\n      setChecked((prev) => !prev);\n      onPressProp?.(e);\n    },\n    [onPressProp, setChecked],\n  );\n\n  const Comp = as || Pressable;\n\n  return (\n    <CheckboxContext.Provider\n      value={{\n        checked,\n        disabled: !!disabled,\n        color,\n        size,\n        variant,\n        highContrast,\n      }}\n    >\n      <Comp\n        ref={ref}\n        accessibilityRole=\"checkbox\"\n        accessibilityState={{\n          ...accessibilityState,\n          checked,\n          disabled: !!disabled,\n        }}\n        disabled={disabled}\n        onPress={onPress}\n        {...restProps}\n      />\n    </CheckboxContext.Provider>\n  );\n});\n\ntype CheckboxIndicatorProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T>;\n\nconst CheckboxIndicator = genericForwardRef(function CheckboxIndicator<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    children: childrenProp,\n    style: styleProp,\n    ...restProps\n  }: CheckboxIndicatorProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { checked, disabled, color, size, variant } = useCheckbox();\n  const { styles } = useStyles(stylesheet, {\n    size,\n    variant,\n  });\n\n  const children = childrenProp ?? (\n    // default icon\n    <CheckboxIcon name=\"checkmark-sharp\" />\n  );\n\n  const Comp = as || View;\n\n  return (\n    <Comp\n      ref={ref}\n      style={[\n        styles.checkboxIndicator(checked, color),\n        disabled && styles.checkboxIndicatorDisabled,\n        styleProp,\n      ]}\n      {...restProps}\n    >\n      {checked && children}\n    </Comp>\n  );\n});\n\ntype CheckboxIconProps = IconProps;\n\nconst CheckboxIcon = React.forwardRef<\n  React.ElementRef<typeof Icon>,\n  CheckboxIconProps\n>(function CheckboxIcon(props: CheckboxIconProps, ref) {\n  const { disabled, color, size, variant, highContrast } = useCheckbox();\n\n  const colorStep: ColorStep =\n    variant === 'solid' ? 'Contrast' : highContrast ? '12' : '11';\n\n  return (\n    <Icon\n      ref={ref}\n      size={size}\n      color={color}\n      colorStep={colorStep}\n      disabled={disabled}\n      highContrast={highContrast}\n      {...props}\n    />\n  );\n});\n\nconst stylesheet = createStyleSheet(({ colors, radius }) => ({\n  checkboxIndicator: (checked: boolean, color: Color) => ({\n    justifyContent: 'center',\n    alignItems: 'center',\n    borderCurve: 'continuous',\n    borderRadius: radius.xs,\n    variants: {\n      size: {\n        sm: {\n          width: 16,\n          height: 16,\n        },\n        md: {\n          width: 20,\n          height: 20,\n        },\n        lg: {\n          width: 24,\n          height: 24,\n        },\n      },\n      variant: {\n        solid: {\n          borderWidth: 1,\n          borderColor: checked ? colors[`${color}9`] : colors.neutral7,\n          backgroundColor: checked ? colors[`${color}9`] : colors.transparent,\n        },\n        outline: {\n          borderWidth: 1,\n          borderColor: colors[`${color}7`],\n          backgroundColor: colors.transparent,\n        },\n        soft: {\n          backgroundColor: colors[`${color}4`],\n        },\n        ghost: {},\n      },\n    },\n  }),\n  checkboxIndicatorDisabled: {\n    borderColor: colors.neutral6,\n    backgroundColor: colors.neutral3,\n    variants: {\n      variant: {\n        solid: {\n          borderWidth: 0,\n        },\n        outline: {\n          borderWidth: 1,\n        },\n        soft: {\n          borderWidth: 0,\n        },\n        ghost: {\n          backgroundColor: colors.transparent,\n        },\n      },\n    },\n  },\n}));\n\nexport { Checkbox, CheckboxIndicator, CheckboxIcon, useCheckbox };\nexport type { CheckboxProps, CheckboxIndicatorProps, CheckboxIconProps };\n",
  },
  {
    name: 'Popup.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'Portal.tsx',
        type: 'component',
      },
      {
        name: 'useControllableState.ts',
        type: 'hook',
      },
      {
        name: 'useInsets.ts',
        type: 'hook',
      },
      {
        name: 'usePositioning.ts',
        type: 'hook',
        registryDependencies: [
          {
            name: 'useInsets.ts',
            type: 'hook',
          },
          {
            name: 'useScreenDimensions.ts',
            type: 'hook',
          },
        ],
      },
      {
        name: 'useScreenDimensions.ts',
        type: 'hook',
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
    ],
    dependencies: ['react-native-svg'],
    code: "import * as React from 'react';\nimport {\n  AccessibilityInfo,\n  BackHandler,\n  ColorValue,\n  findNodeHandle,\n  GestureResponderEvent,\n  LayoutChangeEvent,\n  Pressable,\n  StyleSheet,\n  View,\n} from 'react-native';\nimport Svg, { Path } from 'react-native-svg';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport { Portal, PortalProps } from './Portal';\nimport { useComposedRefs } from '@/utils/composeRefs';\nimport { useControllableState } from '@/hooks/useControllableState';\nimport { usePositioning, Placement, ArrowData } from '@/hooks/usePositioning';\nimport { useScreenDimensions } from '@/hooks/useScreenDimensions';\nimport { useInsets } from '@/hooks/useInsets';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\n\ntype PopupContextValue = {\n  open: boolean;\n  onOpen: () => void;\n  onClose: () => void;\n  anchorRef: React.RefObject<View>;\n  triggerRef: React.RefObject<View>;\n  positionUpdaterRef: React.MutableRefObject<() => void>;\n  closeOnPressOutside: boolean;\n  closeOnBackPress: boolean;\n};\n\nconst PopupContext = React.createContext<PopupContextValue | null>(null);\n\nconst usePopup = () => {\n  const ctx = React.useContext(PopupContext);\n  if (!ctx) {\n    throw new Error('usePopup must be used within a <Popup />');\n  }\n  return ctx;\n};\n\ntype PopupProps = {\n  children?: React.ReactNode;\n  defaultOpen?: boolean;\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  closeOnPressOutside?: boolean;\n  closeOnBackPress?: boolean;\n};\n\nconst Popup = ({\n  children,\n  defaultOpen = false,\n  open: openProp,\n  onOpenChange,\n  closeOnPressOutside = true,\n  closeOnBackPress = true,\n}: PopupProps) => {\n  const [open, setOpen] = useControllableState({\n    defaultValue: defaultOpen,\n    controlledValue: openProp,\n    onControlledChange: onOpenChange,\n  });\n\n  const anchorRef = React.useRef<View>(null);\n  const triggerRef = React.useRef<View>(null);\n  const positionUpdaterRef = React.useRef<() => void>(() => {});\n\n  const onOpen = React.useCallback(() => {\n    setOpen(true);\n  }, [setOpen]);\n\n  const onClose = React.useCallback(() => {\n    setOpen(false);\n    // move accessibility focus back to the trigger\n    if (triggerRef.current) {\n      const reactTag = findNodeHandle(triggerRef.current);\n      if (reactTag === null) {\n        return;\n      }\n      // BUG(react-native): 'setAccessibilityFocus' is not working on iOS\n      AccessibilityInfo.setAccessibilityFocus(reactTag);\n    }\n  }, [setOpen]);\n\n  return (\n    <PopupContext.Provider\n      value={{\n        open,\n        onOpen,\n        onClose,\n        anchorRef,\n        triggerRef,\n        positionUpdaterRef,\n        closeOnPressOutside,\n        closeOnBackPress,\n      }}\n    >\n      {children}\n    </PopupContext.Provider>\n  );\n};\n\ntype PopupTriggerProps<T extends React.ElementType = typeof Pressable> =\n  PolymorphicProps<T>;\n\nconst PopupTrigger = genericForwardRef(function PopupTrigger<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  {\n    as,\n    accessibilityState,\n    disabled,\n    onPress: onPressProp,\n    onLayout: onLayoutProp,\n    ...restProps\n  }: PopupTriggerProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { open, triggerRef, onOpen, onClose, positionUpdaterRef } = usePopup();\n\n  const composedRef = useComposedRefs(ref, triggerRef);\n\n  const onPress = React.useCallback(\n    (e: GestureResponderEvent) => {\n      if (open) {\n        onClose();\n      } else {\n        onOpen();\n      }\n      onPressProp?.(e);\n    },\n    [onPressProp, onOpen, onClose, open],\n  );\n\n  const onLayout = React.useCallback(\n    (e: LayoutChangeEvent) => {\n      positionUpdaterRef.current();\n      onLayoutProp?.(e);\n    },\n    [onLayoutProp, positionUpdaterRef],\n  );\n\n  const Comp = as || Pressable;\n  return (\n    <Comp\n      ref={composedRef}\n      accessibilityRole=\"button\"\n      accessibilityState={{\n        disabled: disabled ?? accessibilityState?.disabled,\n        expanded: open,\n        ...accessibilityState,\n      }}\n      collapsable={false}\n      disabled={disabled}\n      onPress={onPress}\n      onLayout={onLayout}\n      {...restProps}\n    />\n  );\n});\n\ntype PopupAnchorProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T>;\n\nconst PopupAnchor = genericForwardRef(function PopupAnchor<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  { as, onLayout: onLayoutProp, ...restProps }: PopupAnchorProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { anchorRef, positionUpdaterRef } = usePopup();\n\n  const composedRef = useComposedRefs(anchorRef, ref);\n\n  const onLayout = React.useCallback(\n    (e: LayoutChangeEvent) => {\n      positionUpdaterRef.current();\n      onLayoutProp?.(e);\n    },\n    [onLayoutProp, positionUpdaterRef],\n  );\n\n  const Comp = as || View;\n  return (\n    <Comp\n      ref={composedRef}\n      collapsable={false}\n      onLayout={onLayout}\n      {...restProps}\n    />\n  );\n});\n\ntype PopupPortalProps = PortalProps;\n\nconst PopupPortal = ({ children, containerId }: PopupPortalProps) => {\n  const ctx = usePopup();\n  if (!ctx.open) return;\n  return (\n    <Portal containerId={containerId}>\n      <PopupContext.Provider value={ctx}>{children}</PopupContext.Provider>\n    </Portal>\n  );\n};\n\nPopupPortal.displayName = 'PopupPortal';\n\ntype PopupOverlayProps<T extends React.ElementType = typeof Pressable> =\n  PolymorphicProps<T>;\n\nconst PopupOverlay = genericForwardRef(function PopupOverlay<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  { as, onPress: onPressProp, style, ...restProps }: PopupOverlayProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { onClose, closeOnPressOutside } = usePopup();\n\n  const { styles } = useStyles(stylesheet);\n\n  const onPress = React.useCallback(\n    (e: GestureResponderEvent) => {\n      if (closeOnPressOutside) onClose();\n      onPressProp?.(e);\n    },\n    [closeOnPressOutside, onClose, onPressProp],\n  );\n\n  const Comp = as || Pressable;\n\n  return (\n    <Comp\n      ref={ref}\n      accessibilityElementsHidden\n      importantForAccessibility=\"no-hide-descendants\"\n      onPress={onPress}\n      style={(state) => [\n        styles.overlay,\n        typeof style === 'function' ? style(state) : style,\n      ]}\n      {...restProps}\n    />\n  );\n});\n\ntype PopupContentContextValue = {\n  arrowRef: React.RefObject<View>;\n  arrowData: ArrowData | null;\n  canRenderArrow: boolean;\n  placement: Placement;\n};\n\nconst PopupContentContext =\n  React.createContext<PopupContentContextValue | null>(null);\n\nconst usePopupContent = () => {\n  const ctx = React.useContext(PopupContentContext);\n  if (!ctx) {\n    throw new Error(\n      'usePopupContent must be used with in the <PopupContent />',\n    );\n  }\n  return ctx;\n};\n\ntype PopupContentProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T> & {\n    width?: number;\n    minWidth?: number;\n    maxWidth?: number;\n    height?: number;\n    minHeight?: number;\n    maxHeight?: number;\n    mainAxisOffset?: number;\n    arrowMainAxisOffset?: number;\n    placement?: Placement;\n    avoidCollisions?: boolean;\n    coverAnchorToAvoidCollisions?: boolean;\n  };\n\nconst PopupContent = genericForwardRef(function PopupContent<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    children,\n    width,\n    minWidth,\n    maxWidth: maxWidthProp,\n    height,\n    minHeight,\n    maxHeight: maxHeightProp,\n    avoidCollisions = true,\n    coverAnchorToAvoidCollisions = true,\n    mainAxisOffset: mainAxisOffsetProp = 0,\n    arrowMainAxisOffset = 0,\n    placement = 'bottom',\n    onLayout: onLayoutProp,\n    style,\n    ...restProps\n  }: PopupContentProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const {\n    anchorRef,\n    triggerRef,\n    onClose,\n    closeOnBackPress,\n    positionUpdaterRef,\n  } = usePopup();\n\n  const { styles } = useStyles(stylesheet);\n\n  const contentRef = React.useRef<View>(null);\n  const arrowRef = React.useRef(null);\n\n  const {\n    x,\n    y,\n    isPositioned,\n    update,\n    placement: finalPlacement,\n    arrowData,\n    canRenderArrow,\n  } = usePositioning({\n    anchorRef: anchorRef.current ? anchorRef : triggerRef,\n    targetRef: contentRef,\n    arrowRef,\n    avoidCollisions,\n    placement,\n    mainAxisOffset: mainAxisOffsetProp,\n    arrowMainAxisOffset,\n    isTargetHeightFixed: height !== undefined,\n    coverAnchorToAvoidCollisions,\n  });\n\n  const { width: screenWidth, height: screenHeight } = useScreenDimensions();\n  const insets = useInsets();\n  const maxWidth = maxWidthProp ?? screenWidth;\n  const maxHeight = maxHeightProp ?? screenHeight - insets.top - insets.bottom;\n\n  // A default value based on the placement which can be helpful\n  // for animations(like scale animation)\n  const transformOrigin = getTransformOrigin(finalPlacement);\n\n  const composedRef = useComposedRefs(ref, contentRef);\n\n  React.useEffect(() => {\n    const listener = BackHandler.addEventListener('hardwareBackPress', () => {\n      if (closeOnBackPress) {\n        onClose();\n      }\n      return true;\n    });\n    return () => listener.remove();\n  }, [closeOnBackPress, onClose]);\n\n  React.useEffect(() => {\n    positionUpdaterRef.current = () => update();\n  }, [update, positionUpdaterRef]);\n\n  const onLayout = React.useCallback(\n    (e: LayoutChangeEvent) => {\n      update();\n      onLayoutProp?.(e);\n    },\n    [onLayoutProp, update],\n  );\n\n  const Comp = as || View;\n  return (\n    <PopupContentContext.Provider\n      value={{\n        arrowRef,\n        arrowData,\n        canRenderArrow,\n        placement: finalPlacement,\n      }}\n    >\n      <Comp\n        ref={composedRef}\n        accessibilityViewIsModal\n        accessibilityLiveRegion=\"polite\"\n        importantForAccessibility=\"yes\"\n        collapsable={false}\n        onAccessibilityEscape={onClose}\n        onLayout={onLayout}\n        style={[\n          styles.content,\n          isPositioned\n            ? {\n                top: y,\n                left: x,\n                transformOrigin,\n              }\n            : styles.keepOffScreen,\n          style,\n          {\n            width,\n            minWidth,\n            maxWidth,\n            height,\n            minHeight,\n            maxHeight,\n          },\n        ]}\n        {...restProps}\n      >\n        {children}\n      </Comp>\n    </PopupContentContext.Provider>\n  );\n});\n\ntype PopupArrowProps = {\n  arrowSize?: number;\n  arrowColor?: ColorValue;\n};\n\n/**\n * It should be rendered inside the PopupContent component\n */\nconst PopupArrow = React.forwardRef<\n  React.ElementRef<typeof Svg>,\n  PopupArrowProps\n>(({ arrowSize = 6, arrowColor }, forwardedRef) => {\n  const { arrowRef, arrowData, canRenderArrow } = usePopupContent();\n  const { theme } = useStyles();\n\n  const refs = useComposedRefs(arrowRef as any, forwardedRef);\n\n  const width = arrowSize * 2;\n  const height = arrowSize;\n  // stroke width can be added to make the corners rounded with `strokeLinejoin` prop\n  // while keeping the size constant\n  const strokeWidth = 0;\n  const halfStroke = strokeWidth / 2;\n  const color = arrowColor ?? theme.colors.neutral2;\n\n  return (\n    canRenderArrow && (\n      <Svg\n        ref={refs}\n        width={width}\n        height={height}\n        collapsable={false}\n        style={[arrowData?.style]}\n      >\n        <Path\n          d={`M${width / 2} ${halfStroke} L${halfStroke} ${height - halfStroke} L${width - halfStroke} ${height - halfStroke} Z`}\n          stroke={color}\n          strokeWidth={strokeWidth}\n          fill={color}\n        />\n      </Svg>\n    )\n  );\n});\n\nPopupArrow.displayName = 'PopupArrow';\n\ntype PopupCloseProps<T extends React.ElementType = typeof Pressable> =\n  PolymorphicProps<T>;\n\nconst PopupClose = genericForwardRef(function PopupClose<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  { as, onPress: onPressProp, ...restProps }: PopupCloseProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { onClose } = usePopup();\n\n  const onPress = React.useCallback(\n    (e: GestureResponderEvent) => {\n      onClose();\n      onPressProp?.(e);\n    },\n    [onClose, onPressProp],\n  );\n\n  const Comp = as || Pressable;\n  return (\n    <Comp\n      ref={ref}\n      accessibilityRole=\"button\"\n      onPress={onPress}\n      {...restProps}\n    />\n  );\n});\n\nconst stylesheet = createStyleSheet(({ colors, radius }, rt) => ({\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: colors.transparent,\n  },\n  content: {\n    position: 'absolute',\n    backgroundColor: colors.neutral2,\n    borderRadius: radius.lg,\n    borderCurve: 'continuous',\n  },\n  keepOffScreen: {\n    position: 'absolute',\n    top: -9999 - rt.screen.height,\n    left: -9999 - rt.screen.width,\n  },\n}));\n\nfunction getTransformOrigin(placement: Placement) {\n  let result: string;\n  switch (placement) {\n    case 'top':\n      result = 'center bottom';\n      break;\n    case 'top-start':\n      result = 'left bottom';\n      break;\n    case 'top-end':\n      result = 'right bottom';\n      break;\n    case 'bottom':\n      result = 'center top';\n      break;\n    case 'bottom-start':\n      result = 'left top';\n      break;\n    case 'bottom-end':\n      result = 'right top';\n      break;\n    case 'left':\n      result = 'right center';\n      break;\n    case 'left-start':\n      result = 'right top';\n      break;\n    case 'left-end':\n      result = 'right bottom';\n      break;\n    case 'right':\n      result = 'left center';\n      break;\n    case 'right-start':\n      result = 'left top';\n      break;\n    case 'right-end':\n      result = 'left bottom';\n      break;\n    default:\n      result = 'center center';\n  }\n  return result;\n}\n\nexport {\n  Popup,\n  PopupTrigger,\n  PopupAnchor,\n  PopupPortal,\n  PopupOverlay,\n  PopupContent,\n  PopupArrow,\n  PopupClose,\n  PopupContext,\n  usePopup,\n  PopupContentContext,\n  usePopupContent,\n};\nexport type {\n  PopupProps,\n  PopupTriggerProps,\n  PopupAnchorProps,\n  PopupPortalProps,\n  PopupOverlayProps,\n  PopupContentProps,\n  PopupArrowProps,\n  PopupCloseProps,\n  PopupContextValue,\n  PopupContentContextValue,\n};\n",
  },
  {
    name: 'Popover.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'Popup.tsx',
        type: 'component',
        registryDependencies: [
          {
            name: 'Portal.tsx',
            type: 'component',
          },
          {
            name: 'useControllableState.ts',
            type: 'hook',
          },
          {
            name: 'useInsets.ts',
            type: 'hook',
          },
          {
            name: 'usePositioning.ts',
            type: 'hook',
            registryDependencies: [
              {
                name: 'useInsets.ts',
                type: 'hook',
              },
              {
                name: 'useScreenDimensions.ts',
                type: 'hook',
              },
            ],
          },
          {
            name: 'useScreenDimensions.ts',
            type: 'hook',
          },
          {
            name: 'genericForwardRef.ts',
            type: 'utility',
          },
          {
            name: 'components.ts',
            type: 'type',
          },
        ],
        dependencies: ['react-native-svg'],
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
    ],
    dependencies: ['react-native-reanimated'],
    code: "import * as React from 'react';\nimport { View } from 'react-native';\nimport Animated, {\n  Easing,\n  FadeIn,\n  FadeOut,\n  Keyframe,\n  ReduceMotion,\n} from 'react-native-reanimated';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\n\nimport {\n  Popup,\n  PopupAnchor,\n  PopupAnchorProps,\n  PopupArrow,\n  PopupArrowProps,\n  PopupClose,\n  PopupCloseProps,\n  PopupContent,\n  PopupContentProps,\n  PopupOverlay,\n  PopupPortal,\n  PopupProps,\n  PopupTrigger,\n  PopupTriggerProps,\n} from './Popup';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\n\nconst animConfig = {\n  duration: 200,\n  easing: Easing.out(Easing.ease),\n  reduceMotion: ReduceMotion.System,\n} as const;\n\ntype PopoverProps = PopupProps;\n\nconst Popover = Popup;\n\ntype PopoverTriggerProps = PopupTriggerProps;\n\nconst PopoverTrigger = PopupTrigger;\n\ntype PopoverAnchorProps = PopupAnchorProps;\n\nconst PopoverAnchor = PopupAnchor;\n\nconst AnimatedPopupOverlay = Animated.createAnimatedComponent(PopupOverlay);\nconst AnimatedPopupContent = Animated.createAnimatedComponent(PopupContent);\n\ntype PopoverContentProps<T extends React.ElementType = typeof PopupContent> =\n  PopupContentProps<T>;\n\nconst PopoverContent = genericForwardRef(function PopoverContent<\n  T extends React.ElementType<\n    React.ComponentPropsWithoutRef<typeof PopupContent>\n  >,\n>(\n  { style, ...restProps }: PopoverContentProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { styles } = useStyles(stylesheet);\n\n  return (\n    <PopupPortal>\n      <AnimatedPopupOverlay\n        entering={FadeIn.duration(animConfig.duration)\n          .easing(animConfig.easing)\n          .reduceMotion(animConfig.reduceMotion)}\n        exiting={FadeOut.duration(animConfig.duration)\n          .easing(animConfig.easing)\n          .reduceMotion(animConfig.reduceMotion)}\n        style={styles.overlay}\n      />\n      <AnimatedPopupContent\n        ref={ref}\n        style={[styles.content, style]}\n        entering={entryAnim\n          .duration(animConfig.duration)\n          .reduceMotion(animConfig.reduceMotion)}\n        exiting={exitAnim\n          .duration(animConfig.duration)\n          .reduceMotion(animConfig.reduceMotion)}\n        {...restProps}\n      />\n    </PopupPortal>\n  );\n});\n\ntype PopoverArrowProps = PopupArrowProps;\n\nconst PopoverArrow = React.forwardRef<\n  React.ElementRef<typeof PopupArrow>,\n  PopoverArrowProps\n>(function PopoverArrow(props, ref) {\n  const { theme } = useStyles();\n  return (\n    <PopupArrow\n      ref={ref}\n      arrowColor={theme.colors.neutral2}\n      arrowSize={6}\n      {...props}\n    />\n  );\n});\n\ntype PopoverCloseProps = PopupCloseProps;\n\nconst PopoverClose = PopupClose;\n\nconst stylesheet = createStyleSheet(({ colors, space, radius }) => ({\n  overlay: {\n    backgroundColor: colors.overlayMuted,\n  },\n  content: {\n    backgroundColor: colors.neutral2,\n    padding: space[16],\n    borderRadius: radius.md,\n    borderCurve: 'continuous',\n    shadowColor: colors.shadow,\n    shadowOffset: {\n      width: 0,\n      height: 12,\n    },\n    shadowOpacity: 0.4,\n    shadowRadius: 24,\n    elevation: 24,\n  },\n}));\n\nconst entryAnim = new Keyframe({\n  0: {\n    opacity: 0,\n    transform: [{ scale: 0.75 }],\n  },\n  100: {\n    opacity: 1,\n    transform: [{ scale: 1 }],\n    easing: animConfig.easing,\n  },\n});\n\nconst exitAnim = new Keyframe({\n  0: {\n    opacity: 1,\n    transform: [{ scale: 1 }],\n  },\n  100: {\n    opacity: 0,\n    transform: [{ scale: 0.75 }],\n    easing: animConfig.easing,\n  },\n});\n\nexport {\n  Popover,\n  PopoverTrigger,\n  PopoverAnchor,\n  PopoverContent,\n  PopoverArrow,\n  PopoverClose,\n};\n\nexport type {\n  PopoverProps,\n  PopoverTriggerProps,\n  PopoverAnchorProps,\n  PopoverContentProps,\n  PopoverArrowProps,\n  PopoverCloseProps,\n};\n",
  },
  {
    name: 'Dialog.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'Text.tsx',
        type: 'component',
        registryDependencies: [
          {
            name: 'genericForwardRef.ts',
            type: 'utility',
          },
          {
            name: 'components.ts',
            type: 'type',
          },
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'Portal.tsx',
        type: 'component',
      },
      {
        name: 'useControllableState.ts',
        type: 'hook',
      },
      {
        name: 'useInsets.ts',
        type: 'hook',
      },
      {
        name: 'useScreenDimensions.ts',
        type: 'hook',
      },
      {
        name: 'composeRefs.ts',
        type: 'utility',
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
    ],
    dependencies: ['react-native-reanimated'],
    code: "import * as React from 'react';\nimport {\n  AccessibilityInfo,\n  BackHandler,\n  findNodeHandle,\n  GestureResponderEvent,\n  Pressable,\n  StyleProp,\n  StyleSheet,\n  View,\n  ViewStyle,\n} from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\nimport Animated, {\n  Easing,\n  FadeIn,\n  FadeOut,\n  Keyframe,\n  ReduceMotion,\n} from 'react-native-reanimated';\n\nimport { Text, TextProps } from './Text';\nimport { Portal, PortalProps } from './Portal';\nimport { useComposedRefs } from '@/utils/composeRefs';\nimport { useControllableState } from '@/hooks/useControllableState';\nimport { useInsets } from '@/hooks/useInsets';\nimport { useScreenDimensions } from '@/hooks/useScreenDimensions';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\n\nconst animConfig = {\n  duration: 200,\n  easing: Easing.out(Easing.ease),\n  reduceMotion: ReduceMotion.System,\n} as const;\n\ntype DialogContextValue = {\n  closeOnPressOutside: boolean;\n  closeOnBackPress: boolean;\n  defaultOpen: boolean;\n  open: boolean;\n  onOpen: () => void;\n  onClose: () => void;\n  triggerRef: React.RefObject<View>;\n  titleId: string;\n};\n\nconst DialogContext = React.createContext<DialogContextValue | null>(null);\n\nconst useDialog = () => {\n  const ctx = React.useContext(DialogContext);\n  if (!ctx) {\n    throw new Error('useDialog must be used within a <Dialog />');\n  }\n  return ctx;\n};\n\ntype DialogProps = {\n  children: React.ReactNode;\n  closeOnPressOutside?: boolean;\n  closeOnBackPress?: boolean;\n  defaultOpen?: boolean;\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n};\n\nconst Dialog = ({\n  children,\n  closeOnPressOutside = true,\n  closeOnBackPress = true,\n  defaultOpen = false,\n  open: openProp,\n  onOpenChange,\n}: DialogProps) => {\n  const [open, setOpen] = useControllableState({\n    defaultValue: defaultOpen,\n    controlledValue: openProp,\n    onControlledChange: onOpenChange,\n  });\n\n  const triggerRef = React.useRef<View>(null);\n\n  const onOpen = React.useCallback(() => {\n    setOpen(true);\n  }, [setOpen]);\n\n  const onClose = React.useCallback(() => {\n    setOpen(false);\n    // move accessibility focus back to the trigger\n    if (triggerRef.current) {\n      const reactTag = findNodeHandle(triggerRef.current);\n      if (reactTag === null) {\n        return;\n      }\n      // BUG(react-native): 'setAccessibilityFocus' is not working on iOS\n      AccessibilityInfo.setAccessibilityFocus(reactTag);\n    }\n  }, [setOpen]);\n\n  return (\n    <DialogContext.Provider\n      value={{\n        closeOnPressOutside,\n        closeOnBackPress,\n        defaultOpen,\n        open,\n        onOpen,\n        onClose,\n        triggerRef,\n        titleId: React.useId(),\n      }}\n    >\n      {children}\n    </DialogContext.Provider>\n  );\n};\n\ntype DialogTriggerProps<T extends React.ElementType = typeof Pressable> =\n  PolymorphicProps<T>;\n\nconst DialogTrigger = genericForwardRef(function DialogTrigger<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  {\n    as,\n    children,\n    accessibilityState,\n    disabled,\n    onPress: onPressProp,\n    ...restProps\n  }: DialogTriggerProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { open, onOpen, triggerRef } = useDialog();\n\n  const composedRefs = useComposedRefs(triggerRef, ref);\n\n  const onPress = React.useCallback(\n    (e: GestureResponderEvent) => {\n      onOpen();\n      onPressProp?.(e);\n    },\n    [onPressProp, onOpen],\n  );\n\n  const Comp = as || Pressable;\n\n  return (\n    <Comp\n      ref={composedRefs}\n      accessibilityRole=\"button\"\n      accessibilityState={{\n        disabled: disabled ?? accessibilityState?.disabled,\n        expanded: open,\n        ...accessibilityState,\n      }}\n      disabled={disabled}\n      onPress={onPress}\n      {...restProps}\n    >\n      {children}\n    </Comp>\n  );\n});\n\ntype DialogPortalProps = PortalProps;\n\nconst DialogPortal = ({ children, containerId }: DialogPortalProps) => {\n  const ctx = useDialog();\n  if (!ctx.open) return;\n  return (\n    <Portal containerId={containerId}>\n      <DialogContext.Provider value={ctx}>{children}</DialogContext.Provider>\n    </Portal>\n  );\n};\n\nDialogPortal.displayName = 'DialogPortal';\n\nconst AnimatedPressable = Animated.createAnimatedComponent(Pressable);\n\ntype DialogOverlayProps<T extends React.ElementType = typeof Pressable> = Omit<\n  PolymorphicProps<T>,\n  'style'\n> & {\n  // BUG: callback as a style prop is not working with AnimatedPressable\n  style?: StyleProp<ViewStyle>;\n};\n\nconst DialogOverlay = genericForwardRef(function DialogOverlay<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  { as, onPress: onPressProp, style, ...restProps }: DialogOverlayProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { onClose, closeOnPressOutside } = useDialog();\n\n  const { styles } = useStyles(stylesheet);\n\n  const onPress = React.useCallback(\n    (e: GestureResponderEvent) => {\n      if (closeOnPressOutside) onClose();\n      onPressProp?.(e);\n    },\n    [closeOnPressOutside, onClose, onPressProp],\n  );\n\n  const Comp = as || AnimatedPressable;\n\n  return (\n    <Comp\n      ref={ref}\n      accessibilityElementsHidden\n      importantForAccessibility=\"no-hide-descendants\"\n      entering={FadeIn.duration(animConfig.duration)\n        .easing(animConfig.easing)\n        .reduceMotion(animConfig.reduceMotion)}\n      exiting={FadeOut.duration(animConfig.duration)\n        .easing(animConfig.easing)\n        .reduceMotion(animConfig.reduceMotion)}\n      onPress={onPress}\n      style={[styles.overlay, style]}\n      {...restProps}\n    />\n  );\n});\n\ntype DialogContentProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T> & {\n    width?: number;\n    minWidth?: number;\n    maxWidth?: number;\n    height?: number;\n    minHeight?: number;\n    maxHeight?: number;\n    containerStyle?: StyleProp<ViewStyle>;\n  };\n\nconst DialogContent = genericForwardRef(function DialogContent<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(\n  {\n    as,\n    children,\n    width,\n    minWidth,\n    maxWidth = 600,\n    height,\n    minHeight,\n    maxHeight: maxHeightProp,\n    containerStyle: containerStyleProp,\n    style,\n    ...restProps\n  }: DialogContentProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { titleId, onClose, closeOnBackPress } = useDialog();\n\n  const { styles } = useStyles(stylesheet);\n  const { height: screenHeight } = useScreenDimensions();\n  const insets = useInsets();\n  const maxHeight = maxHeightProp ?? screenHeight - insets.top - insets.bottom;\n\n  React.useEffect(() => {\n    const listener = BackHandler.addEventListener('hardwareBackPress', () => {\n      if (closeOnBackPress) {\n        onClose();\n      }\n      return true;\n    });\n    return () => listener.remove();\n  }, [closeOnBackPress, onClose]);\n\n  const Comp = as || Animated.View;\n\n  return (\n    <View\n      pointerEvents=\"box-none\"\n      style={[styles.contentContainerStyle, containerStyleProp]}\n    >\n      <Comp\n        ref={ref}\n        accessibilityLabelledBy={titleId}\n        accessibilityViewIsModal\n        accessibilityLiveRegion=\"polite\"\n        importantForAccessibility=\"yes\"\n        entering={entryAnim\n          .duration(animConfig.duration)\n          .reduceMotion(animConfig.reduceMotion)}\n        exiting={exitAnim\n          .duration(animConfig.duration)\n          .reduceMotion(animConfig.reduceMotion)}\n        onAccessibilityEscape={onClose}\n        style={[\n          styles.content,\n          style,\n          {\n            width,\n            minWidth,\n            maxWidth,\n            height,\n            minHeight,\n            maxHeight,\n          },\n        ]}\n        {...restProps}\n      >\n        {children}\n      </Comp>\n    </View>\n  );\n});\n\ntype DialogTitleProps<T extends React.ElementType = typeof Text> = Omit<\n  TextProps<T>,\n  'nativeID'\n>;\n\nconst DialogTitle = genericForwardRef(function DialogTitle<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Text>>,\n>(props: DialogTitleProps<T>, ref: React.ForwardedRef<T>) {\n  const { titleId } = useDialog();\n\n  return (\n    <Text\n      ref={ref}\n      nativeID={titleId}\n      variant=\"headingSm\"\n      highContrast\n      {...props}\n    />\n  );\n});\n\ntype DialogDescriptionProps<T extends React.ElementType = typeof Text> =\n  TextProps<T>;\n\nconst DialogDescription = genericForwardRef(function DialogDescription<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Text>>,\n>(props: DialogDescriptionProps<T>, ref: React.ForwardedRef<T>) {\n  return <Text ref={ref} variant=\"bodyMd\" {...props} />;\n});\n\ntype DialogCloseProps<T extends React.ElementType = typeof Pressable> =\n  PolymorphicProps<T>;\n\nconst DialogClose = genericForwardRef(function DialogClose<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  { as, onPress: onPressProp, ...restProps }: DialogCloseProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { onClose } = useDialog();\n\n  const onPress = React.useCallback(\n    (e: GestureResponderEvent) => {\n      onClose();\n      onPressProp?.(e);\n    },\n    [onClose, onPressProp],\n  );\n\n  const Comp = as || Pressable;\n  return (\n    <Comp\n      ref={ref}\n      accessibilityRole=\"button\"\n      onPress={onPress}\n      {...restProps}\n    />\n  );\n});\n\nconst stylesheet = createStyleSheet(({ colors, radius, space }, rt) => ({\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: colors.overlay,\n  },\n  contentContainerStyle: {\n    ...StyleSheet.absoluteFillObject,\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    paddingTop: rt.insets.top,\n    paddingBottom: rt.insets.bottom,\n    paddingHorizontal: space[16],\n  },\n  content: {\n    width: '100%',\n    gap: space[8],\n    padding: space[20],\n    borderRadius: radius.lg,\n    borderCurve: 'continuous',\n    backgroundColor: colors.neutral2,\n  },\n}));\n\nconst entryAnim = new Keyframe({\n  0: {\n    opacity: 0,\n    transform: [{ scale: 0.95 }],\n  },\n  100: {\n    opacity: 1,\n    transform: [{ scale: 1 }],\n    easing: animConfig.easing,\n  },\n});\n\nconst exitAnim = new Keyframe({\n  0: {\n    opacity: 1,\n    transform: [{ scale: 1 }],\n  },\n  100: {\n    opacity: 0,\n    transform: [{ scale: 0.95 }],\n    easing: animConfig.easing,\n  },\n});\n\nexport {\n  Dialog,\n  DialogTrigger,\n  DialogPortal,\n  DialogOverlay,\n  DialogContent,\n  DialogTitle,\n  DialogDescription,\n  DialogClose,\n  DialogContext,\n  useDialog,\n};\nexport type {\n  DialogProps,\n  DialogTriggerProps,\n  DialogPortalProps,\n  DialogOverlayProps,\n  DialogContentProps,\n  DialogTitleProps,\n  DialogDescriptionProps,\n  DialogCloseProps,\n  DialogContextValue,\n};\n",
  },
  {
    name: 'DropdownMenu.tsx',
    type: 'component',
    registryDependencies: [
      {
        name: 'Checkbox.tsx',
        type: 'component',
        registryDependencies: [
          {
            name: 'Icon.tsx',
            type: 'component',
            dependencies: [
              '@react-native-vector-icons/common',
              '@react-native-vector-icons/ionicons',
            ],
            devDependencies: ['@types/react-native-vector-icons'],
            registryDependencies: [
              {
                name: 'tokens.ts',
                type: 'style',
              },
            ],
          },
          {
            name: 'useControllableState.ts',
            type: 'hook',
          },
          {
            name: 'genericForwardRef.ts',
            type: 'utility',
          },
          {
            name: 'components.ts',
            type: 'type',
          },
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'Icon.tsx',
        type: 'component',
        dependencies: [
          '@react-native-vector-icons/common',
          '@react-native-vector-icons/ionicons',
        ],
        devDependencies: ['@types/react-native-vector-icons'],
        registryDependencies: [
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'Popup.tsx',
        type: 'component',
        registryDependencies: [
          {
            name: 'Portal.tsx',
            type: 'component',
          },
          {
            name: 'useControllableState.ts',
            type: 'hook',
          },
          {
            name: 'useInsets.ts',
            type: 'hook',
          },
          {
            name: 'usePositioning.ts',
            type: 'hook',
            registryDependencies: [
              {
                name: 'useInsets.ts',
                type: 'hook',
              },
              {
                name: 'useScreenDimensions.ts',
                type: 'hook',
              },
            ],
          },
          {
            name: 'useScreenDimensions.ts',
            type: 'hook',
          },
          {
            name: 'genericForwardRef.ts',
            type: 'utility',
          },
          {
            name: 'components.ts',
            type: 'type',
          },
        ],
        dependencies: ['react-native-svg'],
      },
      {
        name: 'RadioGroup.tsx',
        type: 'component',
        registryDependencies: [
          {
            name: 'useControllableState.ts',
            type: 'hook',
          },
          {
            name: 'genericForwardRef.ts',
            type: 'utility',
          },
          {
            name: 'components.ts',
            type: 'type',
          },
        ],
      },
      {
        name: 'Separator.tsx',
        type: 'component',
        registryDependencies: [
          {
            name: 'genericForwardRef.ts',
            type: 'utility',
          },
          {
            name: 'components.ts',
            type: 'type',
          },
        ],
      },
      {
        name: 'Text.tsx',
        type: 'component',
        registryDependencies: [
          {
            name: 'genericForwardRef.ts',
            type: 'utility',
          },
          {
            name: 'components.ts',
            type: 'type',
          },
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'genericForwardRef.ts',
        type: 'utility',
      },
      {
        name: 'components.ts',
        type: 'type',
      },
      {
        name: 'tokens.ts',
        type: 'style',
      },
    ],
    dependencies: ['react-native-reanimated'],
    code: "import * as React from 'react';\nimport {\n  GestureResponderEvent,\n  Pressable,\n  PressableStateCallbackType,\n  StyleSheet,\n  View,\n} from 'react-native';\nimport { createStyleSheet, useStyles } from 'react-native-unistyles';\nimport Animated, {\n  Easing,\n  LinearTransition,\n  Keyframe,\n  runOnJS,\n  ReduceMotion,\n} from 'react-native-reanimated';\n\nimport {\n  Popup,\n  PopupArrow,\n  PopupClose,\n  PopupCloseProps,\n  PopupContent,\n  PopupContentProps,\n  PopupOverlay,\n  PopupPortal,\n  PopupProps,\n  PopupTrigger,\n  PopupTriggerProps,\n  usePopup,\n} from './Popup';\nimport { Separator, SeparatorProps } from './Separator';\nimport { Text, TextProps } from './Text';\nimport { Icon, IconProps } from './Icon';\nimport { Checkbox, CheckboxIndicator, CheckboxProps } from './Checkbox';\nimport {\n  RadioGroupItem,\n  RadioGroup,\n  RadioGroupProps,\n  RadioGroupItemProps,\n  RadioGroupIndicator,\n  useRadioGroup,\n} from './RadioGroup';\nimport { genericForwardRef } from '@/utils/genericForwardRef';\nimport type { PolymorphicProps } from '@/types/components';\nimport type { Color } from '@/styles/tokens';\n\nconst animConfig = {\n  duration: 200,\n  easing: Easing.out(Easing.ease),\n  reduceMotion: ReduceMotion.System,\n} as const;\n\ntype DropdownMenuProps = PopupProps;\n\nconst DropdownMenu = Popup;\n\ntype DropdownMenuTriggerProps = PopupTriggerProps;\n\nconst DropdownMenuTrigger = PopupTrigger;\n\ntype SubMenu = {\n  id: string;\n  Component: React.ElementType;\n};\ntype DropdownMenuContentContextValue = {\n  addSubMenu: (menu: SubMenu) => void;\n  onSubMenuTriggerPress: (id: string) => void;\n  onSubMenuBackPress: () => void;\n};\n\nconst DropdownMenuContentContext =\n  React.createContext<DropdownMenuContentContextValue | null>(null);\n\nconst useDropdownMenuContent = () => {\n  const ctx = React.useContext(DropdownMenuContentContext);\n  if (!ctx) {\n    throw new Error(\n      'useDropdownMenuContent must be used within a <DropdownMenuContent />',\n    );\n  }\n  return ctx;\n};\n\ntype DropdownMenuContentProps<\n  T extends React.ElementType = typeof PopupContent,\n> = PopupContentProps<T> & {\n  showArrow?: boolean;\n};\n\nconst DropdownMenuContent = genericForwardRef(function DropdownMenuContent<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n>(props: DropdownMenuContentProps<T>, ref: React.ForwardedRef<View>) {\n  const { styles } = useStyles(stylesheet);\n\n  return (\n    <PopupPortal>\n      <PopupOverlay style={styles.overlay} />\n      <DropdownMenuContentImpl ref={ref} {...props} />\n    </PopupPortal>\n  );\n});\n\nconst AnimatedPopupContent = Animated.createAnimatedComponent(PopupContent);\n\ntype DropdownMenuContentImplProps<\n  T extends React.ElementType = typeof PopupContent,\n> = DropdownMenuContentProps<T>;\n\nconst DropdownMenuContentImpl = genericForwardRef(\n  function DropdownMenuContentImpl<\n    T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n  >(\n    {\n      children,\n      showArrow = false,\n      style,\n      ...restProps\n    }: DropdownMenuContentImplProps<T>,\n    ref: React.ForwardedRef<View>,\n  ) {\n    const { styles, theme } = useStyles(stylesheet);\n\n    const subMenusRef = React.useRef<Map<string, SubMenu>>(new Map());\n    const subMenuHistoryRef = React.useRef<string[]>([]);\n    const [activeSubMenu, setActiveSubMenu] = React.useState<SubMenu | null>();\n\n    const [layoutAnimProps, setLayoutAnimProps] = React.useState<{\n      layout: React.ComponentProps<typeof AnimatedPopupContent>['layout'];\n    } | null>(null);\n    const [isEnteringAnimFinished, setIsEnteringAnimFinished] =\n      React.useState(false);\n\n    const addSubMenu = React.useCallback((subMenu: SubMenu) => {\n      subMenusRef.current?.set(subMenu.id, subMenu);\n    }, []);\n\n    const onSubMenuTriggerPress = React.useCallback((id: string) => {\n      const subMenu = subMenusRef.current?.get(id);\n      if (subMenu) {\n        subMenuHistoryRef.current.push(id);\n        setActiveSubMenu(subMenu);\n      }\n    }, []);\n\n    const onSubMenuBackPress = React.useCallback(() => {\n      subMenuHistoryRef.current.pop();\n      const nextId =\n        subMenuHistoryRef.current[subMenuHistoryRef.current.length - 1];\n      if (nextId) {\n        const subMenu = subMenusRef.current?.get(nextId);\n        if (subMenu) {\n          setActiveSubMenu(subMenu);\n        } else {\n          setActiveSubMenu(null);\n        }\n      } else {\n        setActiveSubMenu(null);\n      }\n    }, []);\n\n    const entryAnimCallback = React.useCallback((finished: boolean) => {\n      'worklet';\n      if (finished) {\n        // add layout animation after the entering animation finishes\n        // on Android directly assigning the 'LinearTransition' to the `layout` prop\n        // interupts the `entering` animation\n        runOnJS(setIsEnteringAnimFinished)(true);\n      }\n    }, []);\n\n    React.useEffect(() => {\n      if (isEnteringAnimFinished) {\n        setLayoutAnimProps({\n          layout: LinearTransition.duration(animConfig.duration)\n            .easing(animConfig.easing)\n            .reduceMotion(animConfig.reduceMotion),\n        });\n      }\n    }, [isEnteringAnimFinished]);\n\n    return (\n      <AnimatedPopupContent\n        ref={ref}\n        minWidth={112}\n        entering={entryAnim\n          .duration(animConfig.duration)\n          .reduceMotion(animConfig.reduceMotion)\n          .withCallback(entryAnimCallback)}\n        exiting={exitAnim\n          .duration(animConfig.duration)\n          .reduceMotion(animConfig.reduceMotion)}\n        style={[styles.menuContainer, style]}\n        {...layoutAnimProps}\n        {...restProps}\n      >\n        {showArrow && (\n          <PopupArrow arrowColor={theme.colors.neutral2} arrowSize={6} />\n        )}\n        <DropdownMenuContentContext.Provider\n          value={{\n            addSubMenu,\n            onSubMenuTriggerPress,\n            onSubMenuBackPress,\n          }}\n        >\n          {activeSubMenu ? (\n            <activeSubMenu.Component />\n          ) : (\n            <View accessibilityRole=\"menu\" style={styles.menu}>\n              {children}\n            </View>\n          )}\n        </DropdownMenuContentContext.Provider>\n      </AnimatedPopupContent>\n    );\n  },\n);\n\ntype DropdownMenuLabelProps<T extends React.ElementType = typeof Text> =\n  TextProps<T>;\n\nconst DropdownMenuLabel = genericForwardRef(function DropdownMenuLabel<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Text>>,\n>(\n  { children, style, ...restProps }: DropdownMenuLabelProps<T>,\n  ref: React.ForwardedRef<T>,\n) {\n  const { styles } = useStyles(stylesheet);\n  return (\n    <Text\n      ref={ref}\n      variant=\"labelSm\"\n      style={[styles.label, style]}\n      {...restProps}\n    >\n      {children}\n    </Text>\n  );\n});\n\ntype DropdownMenuItemContextValue = {\n  color: Color;\n  disabled: boolean;\n};\n\nconst DropdownMenuItemContext =\n  React.createContext<DropdownMenuItemContextValue | null>(null);\n\nconst useDropdownMenuItem = () => {\n  const ctx = React.useContext(DropdownMenuItemContext);\n  if (!ctx) {\n    throw new Error(\n      'useDropdownMenuItem must be used within a <DropdownMenuItem />',\n    );\n  }\n  return ctx;\n};\n\ntype DropdownMenuItemProps<T extends React.ElementType = typeof Pressable> =\n  PolymorphicProps<T> & {\n    color?: Color;\n    closeOnPress?: boolean;\n  };\n\nconst DropdownMenuItem = genericForwardRef(function DropdownMenuItem<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Pressable>>,\n>(\n  {\n    as,\n    accessibilityState,\n    color = 'neutral',\n    disabled = false,\n    closeOnPress = true,\n    onPress: onPressProp,\n    style,\n    ...restProps\n  }: DropdownMenuItemProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { onClose } = usePopup();\n\n  const { styles } = useStyles(stylesheet);\n\n  const onPress = React.useCallback(\n    (e: GestureResponderEvent) => {\n      onPressProp?.(e);\n      if (closeOnPress) {\n        onClose();\n      }\n    },\n    [onPressProp, onClose, closeOnPress],\n  );\n\n  const itemStyle = React.useCallback(\n    (state: PressableStateCallbackType) => {\n      return [\n        styles.item(state.pressed, color),\n        typeof style === 'function' ? style(state) : style,\n      ];\n    },\n    [color, style, styles],\n  );\n\n  const Comp = as || Pressable;\n\n  return (\n    <DropdownMenuItemContext.Provider value={{ color, disabled: !!disabled }}>\n      <Comp\n        ref={ref}\n        accessibilityRole=\"menuitem\"\n        accessibilityState={{\n          ...accessibilityState,\n          disabled: !!disabled,\n        }}\n        disabled={disabled}\n        onPress={onPress}\n        style={itemStyle}\n        {...restProps}\n      />\n    </DropdownMenuItemContext.Provider>\n  );\n});\n\ntype DropdownMenuItemTitleProps<T extends React.ElementType = typeof Text> =\n  TextProps<T>;\n\nconst DropdownMenuItemTitle = genericForwardRef(function DropdownMenuItemTitle<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Text>>,\n>(props: DropdownMenuItemTitleProps<T>, ref: React.ForwardedRef<T>) {\n  const { color, disabled } = useDropdownMenuItem();\n  return (\n    <Text\n      ref={ref}\n      variant=\"bodyMd\"\n      color={color}\n      highContrast={color === 'neutral'}\n      disabled={disabled}\n      {...props}\n    />\n  );\n});\n\ntype DropdownMenuItemIconProps = IconProps & {\n  isEndIcon?: boolean;\n};\n\nconst DropdownMenuItemIcon = React.forwardRef<\n  React.ElementRef<typeof Icon>,\n  DropdownMenuItemIconProps\n>(function DropdownMenuItemIcon(\n  { isEndIcon = false, style, ...restProps },\n  ref,\n) {\n  const { color, disabled } = useDropdownMenuItem();\n  const { styles } = useStyles(stylesheet);\n\n  return (\n    <Icon\n      ref={ref}\n      size=\"lg\"\n      color={color}\n      highContrast={color === 'neutral'}\n      disabled={disabled}\n      style={[isEndIcon && styles.endIcon, style]}\n      {...restProps}\n    />\n  );\n});\n\ntype DropdownMenuCheckboxItemProps<\n  T extends React.ElementType = typeof Pressable,\n> = CheckboxProps<T> & {\n  closeOnPress?: boolean;\n};\n\nconst DropdownMenuCheckboxItem = genericForwardRef(\n  function DropdownMenuCheckboxItem<\n    T extends React.ElementType<\n      React.ComponentPropsWithoutRef<typeof Pressable>\n    >,\n  >(\n    {\n      children,\n      color = 'neutral',\n      closeOnPress = true,\n      disabled = false,\n      onPress: onPressProp,\n      style,\n      ...restProps\n    }: DropdownMenuCheckboxItemProps<T>,\n    ref: React.ForwardedRef<View>,\n  ) {\n    const { onClose } = usePopup();\n\n    const { styles } = useStyles(stylesheet);\n\n    const onPress = React.useCallback(\n      (e: GestureResponderEvent) => {\n        onPressProp?.(e);\n        if (closeOnPress) {\n          onClose();\n        }\n      },\n      [onPressProp, onClose, closeOnPress],\n    );\n\n    const itemStyle = (state: PressableStateCallbackType) => {\n      return [\n        styles.item(state.pressed, color),\n        styles.checkboxItem,\n        typeof style === 'function' ? style(state) : style,\n      ];\n    };\n\n    return (\n      <DropdownMenuItemContext.Provider value={{ color, disabled: !!disabled }}>\n        <Checkbox\n          ref={ref}\n          accessibilityRole=\"menuitem\"\n          color={color}\n          variant=\"ghost\"\n          size=\"lg\"\n          highContrast={color === 'neutral'}\n          disabled={disabled}\n          onPress={onPress}\n          style={itemStyle}\n          {...restProps}\n        >\n          {(state) => (\n            <>\n              <CheckboxIndicator />\n              {typeof children === 'function' ? children(state) : children}\n            </>\n          )}\n        </Checkbox>\n      </DropdownMenuItemContext.Provider>\n    );\n  },\n);\n\ntype DropdownMenuRadioGroupProps<\n  T extends React.ElementType = typeof RadioGroup,\n> = RadioGroupProps<T>;\n\nconst DropdownMenuRadioGroup = genericForwardRef(\n  function DropdownMenuRadioGroup<\n    T extends React.ElementType<\n      React.ComponentPropsWithoutRef<typeof RadioGroup>\n    >,\n  >(\n    {\n      color = 'neutral',\n      disabled = false,\n      ...restProps\n    }: DropdownMenuRadioGroupProps<T>,\n    ref: React.ForwardedRef<View>,\n  ) {\n    return (\n      <RadioGroup\n        ref={ref}\n        color={color}\n        size=\"md\"\n        variant=\"ghost\"\n        highContrast={color === 'neutral'}\n        disabled={disabled}\n        {...restProps}\n      />\n    );\n  },\n);\n\ntype DropdownMenuRadioGroupItemProps<\n  T extends React.ElementType = typeof RadioGroupItem,\n> = RadioGroupItemProps<T> & {\n  closeOnPress?: boolean;\n};\n\nconst DropdownMenuRadioGroupItem = genericForwardRef(\n  function DropdownMenuRadioGroupItem<\n    T extends React.ElementType<\n      React.ComponentPropsWithoutRef<typeof RadioGroupItem>\n    >,\n  >(\n    {\n      children,\n      closeOnPress = true,\n      disabled = false,\n      onPress: onPressProp,\n      style,\n      ...restProps\n    }: DropdownMenuRadioGroupItemProps<T>,\n    ref: React.ForwardedRef<View>,\n  ) {\n    const { color } = useRadioGroup();\n    const { onClose } = usePopup();\n\n    const { styles } = useStyles(stylesheet);\n\n    const onPress = React.useCallback(\n      (e: GestureResponderEvent) => {\n        onPressProp?.(e);\n        onClose();\n      },\n      [onPressProp, onClose],\n    );\n\n    const itemStyle = React.useCallback(\n      (state: PressableStateCallbackType) => {\n        return [\n          styles.item(state.pressed, color),\n          styles.checkboxItem,\n          typeof style === 'function' ? style(state) : style,\n        ];\n      },\n      [color, style, styles],\n    );\n\n    return (\n      <DropdownMenuItemContext.Provider value={{ color, disabled: !!disabled }}>\n        <RadioGroupItem\n          ref={ref}\n          accessibilityRole=\"menuitem\"\n          disabled={disabled}\n          onPress={onPress}\n          style={itemStyle}\n          {...restProps}\n        >\n          {(state) => (\n            <>\n              <RadioGroupIndicator />\n              {typeof children === 'function' ? children(state) : children}\n            </>\n          )}\n        </RadioGroupItem>\n      </DropdownMenuItemContext.Provider>\n    );\n  },\n);\n\ntype DropdownMenuCloseProps = PopupCloseProps;\n\nconst DropdownMenuClose = PopupClose;\n\ntype DropdownMenuSeparatorProps<\n  T extends React.ElementType = typeof Separator,\n> = SeparatorProps<T>;\n\nconst DropdownMenuSeparator = genericForwardRef(function DropdownMenuSeparator<\n  T extends React.ElementType<React.ComponentPropsWithoutRef<typeof Separator>>,\n>(\n  { style, ...restProps }: DropdownMenuSeparatorProps<T>,\n  ref: React.ForwardedRef<View>,\n) {\n  const { styles } = useStyles(stylesheet);\n  return (\n    <Separator\n      ref={ref}\n      type=\"hairline\"\n      orientation=\"horizontal\"\n      style={[styles.separator, style]}\n      {...restProps}\n    />\n  );\n});\n\ntype DropdownMenuSubContextValue = {\n  id: string;\n};\n\nconst DropdownMenuSubContext =\n  React.createContext<DropdownMenuSubContextValue | null>(null);\n\nconst useDropdownMenuSub = () => {\n  const ctx = React.useContext(DropdownMenuSubContext);\n  if (!ctx) {\n    throw new Error(\n      'useDropdownMenuSub must be used within a <DropdownMenuSub />',\n    );\n  }\n  return ctx;\n};\n\ntype DropdownMenuSubProps = {\n  children: React.ReactNode;\n};\n\nconst DropdownMenuSub = ({ children }: DropdownMenuSubProps) => {\n  return (\n    <DropdownMenuSubContext.Provider value={{ id: React.useId() }}>\n      {children}\n    </DropdownMenuSubContext.Provider>\n  );\n};\n\ntype DropdownMenuSubTriggerProps<\n  T extends React.ElementType = typeof Pressable,\n> = PolymorphicProps<T>;\n\nconst DropdownMenuSubTrigger = genericForwardRef(\n  function DropdownMenuSubTrigger<\n    T extends React.ElementType<\n      React.ComponentPropsWithoutRef<typeof Pressable>\n    >,\n  >(\n    { as, onPress: onPressProp, ...restProps }: DropdownMenuSubTriggerProps<T>,\n    ref: React.ForwardedRef<View>,\n  ) {\n    const { onSubMenuTriggerPress } = useDropdownMenuContent();\n    const { id } = useDropdownMenuSub();\n\n    const onPress = React.useCallback(\n      (e: GestureResponderEvent) => {\n        onSubMenuTriggerPress(id);\n        onPressProp?.(e);\n      },\n      [onPressProp, id, onSubMenuTriggerPress],\n    );\n\n    const Comp = as || Pressable;\n    return (\n      <>\n        <Comp\n          ref={ref}\n          accessibilityRole=\"menuitem\"\n          onPress={onPress}\n          {...restProps}\n        />\n      </>\n    );\n  },\n);\n\ntype DropdownMenuSubContentProps<T extends React.ElementType = typeof View> =\n  PolymorphicProps<T>;\n\nconst DropdownMenuSubContent = genericForwardRef(\n  function DropdownMenuSubContent<\n    T extends React.ElementType<React.ComponentPropsWithoutRef<typeof View>>,\n  >(\n    { as, children, style, ...restProps }: DropdownMenuSubContentProps<T>,\n    ref: React.ForwardedRef<View>,\n  ) {\n    const { addSubMenu } = useDropdownMenuContent();\n    const { id } = useDropdownMenuSub();\n    const { styles } = useStyles(stylesheet);\n\n    React.useEffect(() => {\n      const Comp = as || View;\n      const menu = {\n        id,\n        Component: () => (\n          <Comp\n            ref={ref}\n            accessibilityRole=\"menu\"\n            style={[styles.menu, style]}\n            {...restProps}\n          >\n            {children}\n          </Comp>\n        ),\n      };\n      addSubMenu(menu);\n    }, [as, addSubMenu, children, ref, id, restProps, style, styles.menu]);\n    return null;\n  },\n);\n\ntype DropdownMenuSubBackTriggerProps<\n  T extends React.ElementType = typeof Pressable,\n> = PolymorphicProps<T>;\n\nconst DropdownMenuSubBackTrigger = genericForwardRef(\n  function DropdownMenuSubBackTrigger<\n    T extends React.ElementType<\n      React.ComponentPropsWithoutRef<typeof Pressable>\n    >,\n  >(\n    {\n      as,\n      onPress: onPressProp,\n      ...restProps\n    }: DropdownMenuSubBackTriggerProps<T>,\n    ref: React.ForwardedRef<View>,\n  ) {\n    const { onSubMenuBackPress } = useDropdownMenuContent();\n\n    const onPress = React.useCallback(\n      (e: GestureResponderEvent) => {\n        onSubMenuBackPress();\n        onPressProp?.(e);\n      },\n      [onPressProp, onSubMenuBackPress],\n    );\n\n    const Comp = as || Pressable;\n    return (\n      <Comp\n        ref={ref}\n        accessibilityRole=\"menuitem\"\n        onPress={onPress}\n        {...restProps}\n      />\n    );\n  },\n);\n\nconst stylesheet = createStyleSheet(({ colors, radius, space }, rt) => ({\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    backgroundColor: colors.transparent,\n  },\n  menuContainer: {\n    padding: 0,\n    backgroundColor: colors.neutral2,\n    borderRadius: radius.lg,\n    borderCurve: 'continuous',\n    shadowColor: colors.shadow,\n    shadowOffset: {\n      width: 0,\n      height: 8,\n    },\n    shadowOpacity: 0.5,\n    shadowRadius: 64,\n    elevation: 64,\n  },\n  menu: {\n    paddingVertical: space[8],\n    borderRadius: radius.lg,\n    overflow: 'hidden',\n  },\n  label: {\n    textAlign: 'left',\n    paddingHorizontal: space[20],\n    paddingVertical: space[8],\n  },\n  item: (pressed: boolean, color: Color) => ({\n    flexDirection: 'row',\n    alignItems: 'center',\n    gap: space[16],\n    paddingHorizontal: space[20],\n    paddingVertical: space[12],\n    backgroundColor: pressed ? colors[`${color}3`] : colors.transparent,\n  }),\n  endIcon: {\n    flexGrow: 1,\n    textAlign: 'right',\n  },\n  checkboxItem: {\n    gap: space[12],\n  },\n  separator: {\n    marginVertical: space[8],\n  },\n}));\n\nconst entryAnim = new Keyframe({\n  0: {\n    opacity: 0,\n    transform: [{ scale: 0.5 }],\n  },\n  100: {\n    opacity: 1,\n    transform: [{ scale: 1 }],\n    easing: animConfig.easing,\n  },\n});\n\nconst exitAnim = new Keyframe({\n  0: {\n    opacity: 1,\n    transform: [{ scale: 1 }],\n  },\n  100: {\n    opacity: 0,\n    transform: [{ scale: 0.5 }],\n    easing: animConfig.easing,\n  },\n});\n\nexport {\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuLabel,\n  DropdownMenuItem,\n  DropdownMenuItemTitle,\n  DropdownMenuItemIcon,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioGroup,\n  DropdownMenuRadioGroupItem,\n  DropdownMenuClose,\n  DropdownMenuSeparator,\n  DropdownMenuSub,\n  DropdownMenuSubTrigger,\n  DropdownMenuSubContent,\n  DropdownMenuSubBackTrigger,\n};\nexport type {\n  DropdownMenuProps,\n  DropdownMenuTriggerProps,\n  DropdownMenuContentProps,\n  DropdownMenuLabelProps,\n  DropdownMenuItemProps,\n  DropdownMenuItemTitleProps,\n  DropdownMenuItemIconProps,\n  DropdownMenuCheckboxItemProps,\n  DropdownMenuRadioGroupProps,\n  DropdownMenuRadioGroupItemProps,\n  DropdownMenuCloseProps,\n  DropdownMenuSeparatorProps,\n  DropdownMenuSubProps,\n  DropdownMenuSubTriggerProps,\n  DropdownMenuSubContentProps,\n  DropdownMenuSubBackTriggerProps,\n};\n",
  },
  {
    name: 'useControllableState.ts',
    type: 'hook',
    code: "import React from 'react';\n\ntype UseControllableStateProps<T> = {\n  defaultValue: T;\n  controlledValue?: T;\n  onControlledChange?: (value: T) => void;\n};\n\nfunction useControllableState<T>({\n  defaultValue,\n  controlledValue,\n  onControlledChange = () => {},\n}: UseControllableStateProps<T>): [T, React.Dispatch<React.SetStateAction<T>>] {\n  const [uncontrolledValue, setUncontrolledValue] =\n    React.useState<T>(defaultValue);\n\n  const isControlled = controlledValue !== undefined;\n\n  const value = isControlled ? (controlledValue as T) : uncontrolledValue;\n\n  const setValue = React.useCallback(\n    (newValue: React.SetStateAction<T>) => {\n      const resolvedValue =\n        typeof newValue === 'function'\n          ? (newValue as (prev: T) => T)(value)\n          : newValue;\n\n      if (isControlled) {\n        // Call onControlledChange when controlled to notify parent of the new value\n        onControlledChange(resolvedValue);\n      } else {\n        // Update internal state when uncontrolled\n        setUncontrolledValue(resolvedValue);\n        // Call onControlledChange even if uncontrolled to notify user with the updated value\n        onControlledChange(resolvedValue);\n      }\n    },\n    [isControlled, onControlledChange, value],\n  );\n\n  return [value, setValue];\n}\n\nexport { useControllableState };\nexport type { UseControllableStateProps };\n",
  },
  {
    name: 'useInsets.ts',
    type: 'hook',
    code: "import React from 'react';\nimport { Dimensions } from 'react-native';\nimport { UnistylesRuntime } from 'react-native-unistyles';\n\nconst useInsets = () => {\n  const [insets, setInsets] = React.useState(UnistylesRuntime.insets);\n\n  React.useEffect(() => {\n    const subscription = Dimensions.addEventListener('change', () => {\n      setInsets(UnistylesRuntime.insets);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return insets;\n};\n\nexport { useInsets };\n",
  },
  {
    name: 'useScreenDimensions.ts',
    type: 'hook',
    code: "import React from 'react';\nimport { Dimensions } from 'react-native';\n\nconst useScreenDimensions = () => {\n  const [dimensions, setDimensions] = React.useState(Dimensions.get('screen'));\n\n  React.useEffect(() => {\n    const subscription = Dimensions.addEventListener('change', ({ screen }) => {\n      setDimensions(screen);\n    });\n\n    return () => subscription.remove();\n  }, []);\n\n  return dimensions;\n};\n\nexport { useScreenDimensions };\n",
  },
  {
    name: 'usePositioning.ts',
    type: 'hook',
    registryDependencies: [
      {
        name: 'useInsets.ts',
        type: 'hook',
      },
      {
        name: 'useScreenDimensions.ts',
        type: 'hook',
      },
    ],
    code: "import React from 'react';\nimport { StyleProp, View, ViewStyle } from 'react-native';\n\nimport { useScreenDimensions } from './useScreenDimensions';\nimport { useInsets } from './useInsets';\n\ntype Rect = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\ntype Placement =\n  | 'top'\n  | 'top-start'\n  | 'top-end'\n  | 'right'\n  | 'right-start'\n  | 'right-end'\n  | 'bottom'\n  | 'bottom-start'\n  | 'bottom-end'\n  | 'left'\n  | 'left-start'\n  | 'left-end';\n\ntype XAxis = 'x';\ntype YAxis = 'y';\ntype Axis = XAxis | YAxis;\ntype Side = 'top' | 'right' | 'bottom' | 'left';\ntype XSide = 'left' | 'right';\ntype YSide = 'top' | 'bottom';\ntype Alignment = 'start' | 'center' | 'end';\ntype Size = { width: number; height: number };\n\ntype ArrowData = {\n  style: StyleProp<ViewStyle>;\n};\n\ntype UsePositioningOptions = {\n  /**\n   * The anchor element to position the target element relative to.\n   */\n  anchorRef: React.RefObject<View>;\n  /**\n   * The target element to position relative to the anchor element.\n   */\n  targetRef: React.RefObject<View>;\n  arrowRef?: React.RefObject<View>;\n  /**\n   * Whether to avoid collisions with the viewport.\n   */\n  avoidCollisions?: boolean;\n  /**\n   * The placement of the target element relative to the anchor element.\n   */\n  placement?: Placement;\n  mainAxisOffset?: number;\n  arrowMainAxisOffset?: number;\n  /**\n   * It helps to calculate the position of the arrow element\n   */\n  isTargetHeightFixed?: boolean;\n  /**\n   * Target element can cover the anchor element to avoid collisions\n   */\n  coverAnchorToAvoidCollisions?: boolean;\n};\ntype UsePositioningReturn = {\n  x: number;\n  y: number;\n  /**\n   * The placement of the target element relative to the anchor element.\n   */\n  placement: Placement;\n  /**\n   * A boolean indicating whether the target element has been positioned.\n   */\n  isPositioned: boolean;\n  /**\n   * A function to update the position of the target element manually.\n   * @returns void\n   */\n  update: () => void;\n  arrowData: ArrowData | null;\n  canRenderArrow: boolean;\n};\n\nconst usePositioning = (\n  options: UsePositioningOptions,\n): UsePositioningReturn => {\n  const {\n    anchorRef,\n    targetRef,\n    arrowRef,\n    placement = 'bottom',\n    avoidCollisions = true,\n    mainAxisOffset = 0,\n    arrowMainAxisOffset = 0,\n    isTargetHeightFixed = false,\n    coverAnchorToAvoidCollisions = false,\n  } = options;\n  const { width: screenWidth, height: screenHeight } = useScreenDimensions();\n  const insets = useInsets();\n\n  const boundaryRect: Rect = React.useMemo(() => {\n    return {\n      x: 0,\n      y: insets.top,\n      width: screenWidth,\n      // don't use window height here due to some issues(such as excluded status bar height) on Android\n      height: screenHeight - insets.top - insets.bottom,\n    };\n  }, [screenWidth, screenHeight, insets.top, insets.bottom]);\n\n  const [anchorRect, setAnchorRect] = React.useState<Rect | null>(null);\n  const [targetSize, setTargetSize] = React.useState<Size | null>(null);\n  const [arrowSize, setArrowSize] = React.useState<Size | null>(null);\n\n  const [data, setData] = React.useState<{\n    x: number;\n    y: number;\n    placement: Placement;\n    isPositioned: boolean;\n    arrowData: ArrowData | null;\n    canRenderArrow: boolean;\n  }>({\n    x: 0,\n    y: 0,\n    placement,\n    isPositioned: false,\n    arrowData: null,\n    canRenderArrow: true,\n  });\n\n  const update = React.useCallback(() => {\n    if (!anchorRect || !targetSize) {\n      return;\n    }\n    // Arrow increases the height of the target element if it is not fixed\n    const _targetHeight =\n      arrowSize?.height && !isTargetHeightFixed\n        ? targetSize.height - arrowSize.height\n        : targetSize.height;\n    const _targetSize = {\n      ...targetSize,\n      height: _targetHeight,\n    };\n    const _arrowSize = arrowSize ?? { width: 0, height: 0 };\n\n    const xData = calcX({\n      anchorRect,\n      boundaryRect,\n      targetSize: _targetSize,\n      arrowSize: _arrowSize,\n      avoidCollisions,\n      placement,\n      mainAxisOffset,\n      coverAnchorToAvoidCollisions,\n    });\n\n    const yData = calcY({\n      anchorRect,\n      boundaryRect,\n      targetSize: _targetSize,\n      arrowSize: _arrowSize,\n      avoidCollisions,\n      placement,\n      mainAxisOffset,\n      coverAnchorToAvoidCollisions,\n    });\n\n    const mainAxis = getMainAxis(placement);\n    const side = mainAxis === 'x' ? xData.side : yData.side;\n    const alignment = mainAxis === 'x' ? yData.alignment : xData.alignment;\n    const newPlacement: Placement =\n      alignment === 'center' ? side : `${side}-${alignment}`;\n    const canRenderArrow = arrowRef?.current\n      ? mainAxis === 'x'\n        ? xData.canRenderArrow\n        : yData.canRenderArrow\n      : false;\n\n    setData({\n      x: xData.x,\n      y: yData.y,\n      placement: newPlacement,\n      isPositioned: true,\n      canRenderArrow,\n      arrowData: arrowSize\n        ? getArrowData({\n            x: xData.x,\n            y: yData.y,\n            anchorRect,\n            arrowSize,\n            mainAxis,\n            side,\n            arrowMainAxisOffset,\n          })\n        : null,\n    });\n  }, [\n    anchorRect,\n    boundaryRect,\n    targetSize,\n    avoidCollisions,\n    placement,\n    mainAxisOffset,\n    arrowSize,\n    arrowMainAxisOffset,\n    isTargetHeightFixed,\n    coverAnchorToAvoidCollisions,\n    arrowRef,\n  ]);\n\n  React.useLayoutEffect(() => {\n    anchorRef.current?.measure((x, y, width, height, pageX, pageY) => {\n      setAnchorRect({\n        x: pageX,\n        y: pageY,\n        width,\n        height,\n      });\n    });\n\n    targetRef.current?.measure((x, y, width, height) => {\n      setTargetSize({\n        width,\n        height,\n      });\n    });\n\n    arrowRef?.current?.measure((x, y, width, height) => {\n      setArrowSize({\n        width,\n        height,\n      });\n    });\n  }, [anchorRef, targetRef, arrowRef]);\n\n  React.useLayoutEffect(() => {\n    update();\n  }, [update]);\n\n  return { ...data, update };\n};\n\nfunction getMainAxis(placement: Placement): Axis {\n  const side = placement.split('-')[0] as Side;\n  if (side === 'top' || side === 'bottom') {\n    return 'y';\n  } else {\n    return 'x';\n  }\n}\n\nfunction getLeadingSide(axis: Axis): Side {\n  return axis === 'x' ? 'left' : 'top';\n}\n\nfunction getTrailingSide(axis: Axis): Side {\n  return axis === 'x' ? 'right' : 'bottom';\n}\n\ntype CalcXParams = {\n  anchorRect: Rect;\n  boundaryRect: Rect;\n  targetSize: Size;\n  arrowSize: Size;\n  placement: Placement;\n  avoidCollisions: boolean;\n  mainAxisOffset: number;\n  coverAnchorToAvoidCollisions: boolean;\n};\ntype CalcXReturn = {\n  x: number;\n  side: Side;\n  alignment: Alignment;\n  canRenderArrow: boolean;\n};\nfunction calcX({\n  anchorRect,\n  boundaryRect,\n  targetSize,\n  arrowSize,\n  avoidCollisions = true,\n  placement,\n  mainAxisOffset,\n  coverAnchorToAvoidCollisions,\n}: CalcXParams): CalcXReturn {\n  const { x: anchorX, width: anchorWidth } = anchorRect;\n  const { width: targetWidth } = targetSize;\n\n  const [initialSide, initialAlignment = 'center'] = placement.split('-') as [\n    Side,\n    Alignment,\n  ];\n  let x: number;\n  let side: Side = initialSide;\n  let alignment: Alignment = initialAlignment;\n  let canRenderArrow = true;\n  switch (placement) {\n    case 'top':\n    case 'bottom':\n      const d = (anchorWidth - targetWidth) / 2;\n      x = anchorX + d;\n      break;\n    case 'top-start':\n    case 'bottom-start':\n      x = anchorX;\n      break;\n    case 'top-end':\n    case 'bottom-end':\n      x = anchorX + anchorWidth - targetWidth;\n      break;\n    case 'left':\n    case 'left-start':\n    case 'left-end':\n      x = anchorX - targetWidth - mainAxisOffset - arrowSize.height;\n      break;\n    case 'right':\n    case 'right-start':\n    case 'right-end':\n      x = anchorX + anchorWidth + mainAxisOffset + arrowSize.height;\n      break;\n  }\n  if (avoidCollisions) {\n    const safe = getSafeCoord<XAxis>({\n      axis: 'x',\n      coord: x,\n      boundaryCoord: boundaryRect.x,\n      boundaryClientProp: boundaryRect.width,\n      anchorCoord: anchorX,\n      anchorClientProp: anchorWidth,\n      targetClientProp: targetWidth,\n      placement,\n      mainAxisOffset,\n      arrowSize,\n      coverAnchorToAvoidCollisions,\n    });\n    x = safe.coord;\n    side = safe.side;\n    alignment = safe.alignment;\n    canRenderArrow = safe.canRenderArrow;\n  }\n  return {\n    x,\n    side,\n    alignment,\n    canRenderArrow,\n  };\n}\n\ntype CalcYParams = {\n  anchorRect: Rect;\n  boundaryRect: Rect;\n  targetSize: Size;\n  arrowSize: Size;\n  placement: Placement;\n  avoidCollisions: boolean;\n  mainAxisOffset: number;\n  coverAnchorToAvoidCollisions: boolean;\n};\ntype CalcYReturn = {\n  y: number;\n  side: Side;\n  alignment: Alignment;\n  canRenderArrow: boolean;\n};\nfunction calcY({\n  anchorRect,\n  boundaryRect,\n  targetSize,\n  arrowSize,\n  avoidCollisions = true,\n  placement,\n  mainAxisOffset,\n  coverAnchorToAvoidCollisions,\n}: CalcYParams): CalcYReturn {\n  const { y: anchorY, height: anchorHeight } = anchorRect;\n  const { height: targetHeight } = targetSize;\n  const [initialSide, initialAlignment = 'center'] = placement.split('-') as [\n    Side,\n    Alignment,\n  ];\n  let y: number;\n  let side: Side = initialSide;\n  let alignment: Alignment = initialAlignment;\n  let canRenderArrow = true;\n  switch (placement) {\n    case 'top':\n    case 'top-start':\n    case 'top-end':\n      y = anchorY - targetHeight - mainAxisOffset - arrowSize.height;\n      break;\n    case 'bottom':\n    case 'bottom-start':\n    case 'bottom-end':\n      y = anchorY + anchorHeight + mainAxisOffset + arrowSize.height;\n      break;\n    case 'left':\n    case 'right':\n      const d = (anchorHeight - targetHeight) / 2;\n      y = anchorY + d;\n      break;\n    case 'left-start':\n    case 'right-start':\n      y = anchorY;\n      break;\n    case 'left-end':\n    case 'right-end':\n      y = anchorY + anchorHeight - targetHeight;\n      break;\n  }\n  if (avoidCollisions) {\n    const safe = getSafeCoord<YAxis>({\n      axis: 'y',\n      coord: y,\n      boundaryCoord: boundaryRect.y,\n      boundaryClientProp: boundaryRect.height,\n      anchorCoord: anchorY,\n      anchorClientProp: anchorHeight,\n      targetClientProp: targetHeight,\n      placement,\n      mainAxisOffset,\n      arrowSize,\n      coverAnchorToAvoidCollisions,\n    });\n    y = safe.coord;\n    side = safe.side;\n    alignment = safe.alignment;\n    canRenderArrow = safe.canRenderArrow;\n  }\n  return {\n    y,\n    side,\n    alignment,\n    canRenderArrow,\n  };\n}\n\ntype GetSafeCoordParams<T extends Axis> = {\n  axis: T;\n  coord: number;\n  boundaryCoord: number;\n  boundaryClientProp: number;\n  anchorCoord: number;\n  anchorClientProp: number;\n  targetClientProp: number;\n  placement: Placement;\n  mainAxisOffset: number;\n  arrowSize: Size;\n  coverAnchorToAvoidCollisions: boolean;\n};\ntype GetSafeCoordReturn = {\n  coord: number;\n  side: Side;\n  alignment: Alignment;\n  canRenderArrow: boolean;\n};\nfunction getSafeCoord<T extends Axis>({\n  axis,\n  coord,\n  boundaryCoord,\n  boundaryClientProp,\n  anchorCoord,\n  anchorClientProp,\n  targetClientProp,\n  placement,\n  mainAxisOffset,\n  arrowSize,\n  coverAnchorToAvoidCollisions,\n}: GetSafeCoordParams<T>): GetSafeCoordReturn {\n  const [initialSide, initialAlignment = 'center'] = placement.split('-') as [\n    T extends XAxis ? XSide : YSide,\n    Alignment,\n  ];\n  let newCoord: number = coord;\n  let newSide: Side = initialSide;\n  let newAlignment: Alignment = initialAlignment;\n  let canRenderArrow: boolean = true;\n\n  const { collision, collisionSide } = getCollision({\n    axis,\n    coord,\n    boundaryCoord,\n    boundaryClientProp,\n    targetClientProp,\n  });\n\n  if (!collision) {\n    return {\n      coord: newCoord,\n      side: newSide,\n      alignment: newAlignment,\n      canRenderArrow,\n    };\n  }\n\n  const mainAxis = getMainAxis(placement);\n\n  // If the mainAxis is `axis` param, then we only need to change its Side\n  // otherwise we need to change Alignment\n\n  if (mainAxis === axis) {\n    const data = getSafeCoordOnMainAxis<T>({\n      mainAxis: axis,\n      mainAxisOffset,\n      initialSide,\n      boundaryCoord,\n      boundaryClientProp,\n      anchorCoord,\n      anchorClientProp,\n      targetClientProp,\n      arrowSize,\n      coverAnchorToAvoidCollisions,\n    });\n    newCoord = data.coord;\n    newSide = data.side;\n    canRenderArrow = data.canRenderArrow;\n  } else {\n    const data = getSafeCoordOnCrossAxis<T>({\n      crossAxis: axis,\n      collisionSide,\n      boundaryCoord,\n      boundaryClientProp,\n      anchorCoord,\n      anchorClientProp,\n      targetClientProp,\n    });\n    newCoord = data.coord;\n    newAlignment = data.alignment;\n  }\n\n  return {\n    coord: newCoord,\n    side: newSide,\n    alignment: newAlignment,\n    canRenderArrow,\n  };\n}\n\ntype GetCollisionParams = {\n  axis: Axis;\n  coord: number;\n  boundaryCoord: number;\n  boundaryClientProp: number;\n  targetClientProp: number;\n};\ntype GetCollisionReturn =\n  | {\n      collision: true;\n      collisionSide: Side;\n    }\n  | {\n      collision: false;\n      collisionSide: null;\n    };\nfunction getCollision({\n  axis,\n  coord,\n  boundaryCoord,\n  boundaryClientProp,\n  targetClientProp,\n}: GetCollisionParams): GetCollisionReturn {\n  if (coord < boundaryCoord) {\n    return {\n      collision: true,\n      collisionSide: getLeadingSide(axis),\n    };\n  } else if (coord + targetClientProp > boundaryClientProp) {\n    return {\n      collision: true,\n      collisionSide: getTrailingSide(axis),\n    };\n  } else {\n    return {\n      collision: false,\n      collisionSide: null,\n    };\n  }\n}\n\ntype GetSafeCoordOnMainAxisParams<T extends Axis> = {\n  mainAxis: T;\n  mainAxisOffset: number;\n  initialSide: T extends XAxis ? XSide : YSide;\n  boundaryCoord: number;\n  boundaryClientProp: number;\n  anchorCoord: number;\n  anchorClientProp: number;\n  targetClientProp: number;\n  arrowSize: Size;\n  coverAnchorToAvoidCollisions: boolean;\n};\ntype GetSafeCoordOnMainAxisReturn = {\n  coord: number;\n  side: Side;\n  canRenderArrow: boolean;\n};\nfunction getSafeCoordOnMainAxis<T extends Axis>({\n  mainAxis,\n  mainAxisOffset,\n  initialSide,\n  boundaryCoord,\n  boundaryClientProp,\n  anchorCoord,\n  anchorClientProp,\n  targetClientProp,\n  arrowSize,\n  coverAnchorToAvoidCollisions,\n}: GetSafeCoordOnMainAxisParams<T>): GetSafeCoordOnMainAxisReturn {\n  let coord: number;\n  let side: Side;\n  let canRenderArrow: boolean = true;\n\n  const leadingSide = getLeadingSide(mainAxis);\n  const trailingSide = getTrailingSide(mainAxis);\n\n  // check if the anchor element is inside the boundary or not\n  if (anchorCoord + anchorClientProp < boundaryCoord) {\n    // outside the boundary on the 'leading' side\n    side = trailingSide;\n    coord = boundaryCoord + mainAxisOffset + arrowSize.height;\n  } else if (anchorCoord > boundaryClientProp) {\n    // outside the boundary on the 'trailing' side\n    side = leadingSide;\n    coord =\n      boundaryClientProp - targetClientProp - mainAxisOffset - arrowSize.height;\n  } else {\n    // the anchor element is inside the boundary\n    // the new side is determined based on which side area is bigger\n    side = getBiggerAreaSide<T>({\n      mainAxis,\n      initialSide,\n      boundaryCoord,\n      boundaryClientProp,\n      anchorCoord,\n      anchorClientProp,\n      mainAxisOffset,\n    });\n    if (side === leadingSide) {\n      coord =\n        anchorCoord - targetClientProp - mainAxisOffset - arrowSize.height;\n      if (coverAnchorToAvoidCollisions) {\n        if (coord < boundaryCoord) {\n          coord = boundaryCoord;\n          canRenderArrow = false;\n        }\n      }\n    } else {\n      coord =\n        anchorCoord + anchorClientProp + mainAxisOffset + arrowSize.height;\n      if (coverAnchorToAvoidCollisions) {\n        if (coord > boundaryClientProp - targetClientProp) {\n          coord = Math.max(\n            boundaryClientProp - targetClientProp,\n            boundaryCoord,\n          );\n          canRenderArrow = false;\n        }\n      }\n    }\n  }\n\n  return {\n    coord,\n    side,\n    canRenderArrow,\n  };\n}\n\ntype GetSafeCoordOnCrossAxisParams<T extends Axis> = {\n  crossAxis: T;\n  collisionSide: Side;\n  boundaryCoord: number;\n  boundaryClientProp: number;\n  anchorCoord: number;\n  anchorClientProp: number;\n  targetClientProp: number;\n};\ntype GetSafeCoordOnCrossAxisReturn = {\n  coord: number;\n  alignment: Alignment;\n};\nfunction getSafeCoordOnCrossAxis<T extends Axis>({\n  crossAxis,\n  collisionSide,\n  boundaryCoord,\n  boundaryClientProp,\n  anchorCoord,\n  anchorClientProp,\n  targetClientProp,\n}: GetSafeCoordOnCrossAxisParams<T>): GetSafeCoordOnCrossAxisReturn {\n  let coord: number;\n  let alignment: Alignment;\n\n  const leadingSide = getLeadingSide(crossAxis);\n\n  if (anchorCoord + anchorClientProp < boundaryCoord) {\n    // outside the boundary on the 'leading' side\n    coord = boundaryCoord;\n    alignment = 'start';\n  } else if (anchorCoord + anchorClientProp > boundaryClientProp) {\n    // outside the boundary on the 'trailing' side\n    coord = boundaryClientProp - targetClientProp;\n    alignment = 'end';\n  } else {\n    // inside the boundary\n    // the new alignment is determined based on which alignment is closest to the anchor\n    if (collisionSide === leadingSide) {\n      coord = boundaryCoord;\n      alignment = getClosestAlignment({\n        coord,\n        anchorCoord,\n        anchorClientProp,\n        targetClientProp,\n      });\n    } else {\n      coord = boundaryClientProp - targetClientProp;\n      alignment = getClosestAlignment({\n        coord,\n        anchorCoord,\n        anchorClientProp,\n        targetClientProp,\n      });\n    }\n  }\n\n  return {\n    coord,\n    alignment,\n  };\n}\n\ntype GetBiggerAreaSideParams<T extends Axis> = {\n  mainAxis: T;\n  initialSide: T extends XAxis ? XSide : YSide;\n  boundaryCoord: number;\n  boundaryClientProp: number;\n  anchorCoord: number;\n  anchorClientProp: number;\n  mainAxisOffset: number;\n};\n/**\n * Only pass the main axis values\n */\nfunction getBiggerAreaSide<T extends Axis>({\n  mainAxis,\n  initialSide,\n  boundaryCoord,\n  boundaryClientProp,\n  anchorCoord,\n  anchorClientProp,\n  mainAxisOffset,\n}: GetBiggerAreaSideParams<T>) {\n  const leadingSide = getLeadingSide(mainAxis);\n  const trailingSide = getTrailingSide(mainAxis);\n\n  anchorCoord = Math.max(0, anchorCoord);\n  const leadingSideArea = anchorCoord - mainAxisOffset - boundaryCoord;\n  const trailingSideArea =\n    boundaryClientProp - (anchorCoord + anchorClientProp + mainAxisOffset);\n\n  if (leadingSideArea > trailingSideArea) {\n    return leadingSide;\n  } else if (leadingSideArea < trailingSideArea) {\n    return trailingSide;\n  } else {\n    return initialSide;\n  }\n}\n\ntype GetClosestAlignmentParams = {\n  coord: number;\n  anchorCoord: number;\n  anchorClientProp: number;\n  targetClientProp: number;\n};\n/**\n * Only pass the cross axis values\n */\nfunction getClosestAlignment({\n  coord,\n  anchorCoord,\n  anchorClientProp,\n  targetClientProp,\n}: GetClosestAlignmentParams): Alignment {\n  const anchorShiftCoord = anchorCoord + anchorClientProp / 2;\n  const targetHalfSize = targetClientProp / 2;\n  // d is the distance between anchorShiftCoord and coord\n  const d = anchorShiftCoord - coord;\n  if (d <= 0 || d < targetHalfSize) {\n    return 'start';\n  } else if (d > targetHalfSize) {\n    return 'end';\n  } else {\n    return 'center';\n  }\n}\n\ntype GetArrowDataParams = {\n  x: number;\n  y: number;\n  anchorRect: Rect;\n  arrowSize: Size;\n  mainAxis: Axis;\n  side: Side;\n  arrowMainAxisOffset: number;\n};\nfunction getArrowData({\n  x,\n  y,\n  anchorRect,\n  arrowSize,\n  mainAxis,\n  side,\n  arrowMainAxisOffset,\n}: GetArrowDataParams): ArrowData {\n  let rotate: number = 0;\n  let positionStyle: ViewStyle = {};\n\n  if (mainAxis === 'x') {\n    const anchorShiftY = anchorRect.y + anchorRect.height / 2;\n    const fy = anchorShiftY - y;\n    let arrowY = fy - arrowSize.height / 2;\n    const arrowHeightAt90DegRotation =\n      arrowSize.width - (arrowSize.width - arrowSize.height) / 2;\n    if (side === 'left') {\n      rotate = 90;\n      positionStyle = {\n        top: arrowY,\n        right: -arrowHeightAt90DegRotation + arrowMainAxisOffset,\n      };\n    } else {\n      rotate = -90;\n      positionStyle = {\n        top: arrowY,\n        left: -arrowHeightAt90DegRotation + arrowMainAxisOffset,\n      };\n    }\n  } else {\n    const anchorShiftX = anchorRect.x + anchorRect.width / 2;\n    const fx = anchorShiftX - x;\n    let arrowX = fx - arrowSize.width / 2;\n    if (side === 'top') {\n      rotate = 180;\n      positionStyle = {\n        bottom: -arrowSize.height + arrowMainAxisOffset,\n        left: arrowX,\n      };\n    } else {\n      rotate = 0;\n      positionStyle = {\n        top: -arrowSize.height + arrowMainAxisOffset,\n        left: arrowX,\n      };\n    }\n  }\n\n  return {\n    style: {\n      position: 'absolute',\n      ...positionStyle,\n      transform: [\n        {\n          rotate: `${rotate}deg`,\n        },\n      ],\n    },\n  };\n}\n\nexport { usePositioning };\nexport type {\n  Placement,\n  Side,\n  Alignment,\n  Rect,\n  Axis,\n  UsePositioningOptions,\n  UsePositioningReturn,\n  ArrowData,\n};\n",
  },
  {
    name: 'tokens.ts',
    type: 'style',
    code: "// Colors\nimport {\n  blackA,\n  whiteA,\n  gray,\n  grayDark,\n  red as radixRed,\n  redDark as radixRedDark,\n  green as radixGreen,\n  greenDark as radixGreenDark,\n} from '@radix-ui/colors';\n\nconst primary = {\n  primary1: '#fcfdfe',\n  primary2: '#f6f9ff',\n  primary3: '#ecf2ff',\n  primary4: '#ddeaff',\n  primary5: '#cddfff',\n  primary6: '#b9d2ff',\n  primary7: '#a2bfff',\n  primary8: '#81a5f9',\n  primary9: '#3a6af8',\n  primary10: '#345fde',\n  primary11: '#305ad8',\n  primary12: '#192d63',\n\n  primaryContrast: '#fff',\n} as const;\n\nconst primaryDark = {\n  primary1: '#0c111c',\n  primary2: '#111725',\n  primary3: '#172448',\n  primary4: '#1d2e61',\n  primary5: '#243974',\n  primary6: '#2d4484',\n  primary7: '#375098',\n  primary8: '#405eb2',\n  primary9: '#3d63dd',\n  primary10: '#3f5cb0',\n  primary11: '#93b4ff',\n  primary12: '#d5e2ff',\n\n  primaryContrast: '#fff',\n} as const;\n\nconst neutral = {\n  neutral1: gray.gray1,\n  neutral2: gray.gray2,\n  neutral3: gray.gray3,\n  neutral4: gray.gray4,\n  neutral5: gray.gray5,\n  neutral6: gray.gray6,\n  neutral7: gray.gray7,\n  neutral8: gray.gray8,\n  neutral9: gray.gray9,\n  neutral10: gray.gray10,\n  neutral11: gray.gray11,\n  neutral12: gray.gray12,\n\n  neutralContrast: '#fff',\n} as const;\n\nconst neutralDark = {\n  neutral1: grayDark.gray1,\n  neutral2: grayDark.gray2,\n  neutral3: grayDark.gray3,\n  neutral4: grayDark.gray4,\n  neutral5: grayDark.gray5,\n  neutral6: grayDark.gray6,\n  neutral7: grayDark.gray7,\n  neutral8: grayDark.gray8,\n  neutral9: grayDark.gray9,\n  neutral10: grayDark.gray10,\n  neutral11: grayDark.gray11,\n  neutral12: grayDark.gray12,\n\n  neutralContrast: '#fff',\n} as const;\n\nconst red = {\n  ...radixRed,\n\n  redContrast: '#fff',\n} as const;\n\nconst redDark = {\n  ...radixRedDark,\n\n  redContrast: '#fff',\n} as const;\n\nconst green = {\n  ...radixGreen,\n\n  greenContrast: '#fff',\n} as const;\n\nconst greenDark = {\n  ...radixGreenDark,\n\n  greenContrast: '#fff',\n} as const;\n\nconst commonColors = {\n  white: '#fff',\n  black: '#000',\n  transparent: 'transparent',\n  ...blackA,\n  ...whiteA,\n} as const;\n\nexport const lightThemeColors = {\n  ...commonColors,\n  ...primary,\n  ...neutral,\n  ...red,\n  ...green,\n\n  foreground: '#000',\n  background: '#fff',\n  overlay: blackA.blackA6,\n  overlayMuted: blackA.blackA3,\n  shadow: blackA.blackA7,\n} as const;\n\nexport const darkThemeColors = {\n  ...commonColors,\n  ...primaryDark,\n  ...neutralDark,\n  ...redDark,\n  ...greenDark,\n\n  foreground: '#fff',\n  background: '#020202',\n  overlay: blackA.blackA8,\n  overlayMuted: blackA.blackA6,\n  shadow: blackA.blackA11,\n} as const;\n\nexport type Color = 'primary' | 'neutral' | 'red' | 'green';\nexport type ColorStep =\n  | '1'\n  | '2'\n  | '3'\n  | '4'\n  | '5'\n  | '6'\n  | '7'\n  | '8'\n  | '9'\n  | '10'\n  | '11'\n  | '12'\n  | 'Contrast';\n\n// Breakpoints\nexport const breakpoints = {\n  mobile: 0,\n  tablet: 768,\n} as const;\n\nexport type Breakpoint = keyof typeof breakpoints;\nexport type Breakpoints = typeof breakpoints;\n\n// Radius\nexport const radius = {\n  none: 0,\n  xs: 4,\n  sm: 8,\n  md: 12,\n  lg: 16,\n  xl: 24,\n  full: 9999,\n} as const;\n\nexport type Radius = keyof typeof radius;\n\n// Space\nexport const space = {\n  0: 0,\n  1: 1,\n  2: 2,\n  4: 4,\n  6: 6,\n  8: 8,\n  10: 10,\n  12: 12,\n  14: 14,\n  16: 16,\n  18: 18,\n  20: 20,\n  24: 24,\n  28: 28,\n  32: 32,\n  36: 36,\n  40: 40,\n  44: 44,\n  48: 48,\n  56: 56,\n  64: 64,\n  80: 80,\n  96: 96,\n  112: 112,\n  128: 128,\n  144: 144,\n} as const;\n\nexport type Space = keyof typeof space;\n\n// Typography\n// font name should be the same as the file name\nexport type FontFamily =\n  | 'Inter-Regular'\n  | 'Inter-Medium'\n  | 'Inter-SemiBold'\n  | 'Inter-Bold'\n  | 'InterDisplay-ExtraBold';\n\nexport const fontFamilies = {\n  interRegular: 'Inter-Regular',\n  interMedium: 'Inter-Medium',\n  interSemiBold: 'Inter-SemiBold',\n  interBold: 'Inter-Bold',\n  interDisplayExtraBold: 'InterDisplay-ExtraBold',\n} as const;\n\n// Using the `Major Second` type scale (1.125)\n// Base font size: 16px\nexport const fontSizes = {\n  10: 10,\n  11: 11,\n  12: 12,\n  14: 14,\n  16: 16,\n  18: 18,\n  20: 20,\n  22: 22,\n  25: 25,\n  28: 28,\n  32: 32,\n  36: 36,\n  40: 40,\n  45: 45,\n  51: 51,\n  57: 57,\n  64: 64,\n  72: 72,\n} as const;\n\nexport type FontSize = keyof typeof fontSizes;\n\nexport type TextVariant = {\n  fontFamily: FontFamily;\n  fontSize: FontSize;\n  lineHeight: number;\n};\n\nexport type TextVariants = {\n  displayLg: TextVariant;\n  displayMd: TextVariant;\n  displaySm: TextVariant;\n  displayXs: TextVariant;\n  headingLg: TextVariant;\n  headingMd: TextVariant;\n  headingSm: TextVariant;\n  headingXs: TextVariant;\n  labelLg: TextVariant;\n  labelMd: TextVariant;\n  labelSm: TextVariant;\n  labelXs: TextVariant;\n  bodyLg: TextVariant;\n  bodyMd: TextVariant;\n  bodySm: TextVariant;\n  bodyXs: TextVariant;\n};\n\nexport const textVariants: TextVariants = {\n  displayLg: {\n    fontFamily: fontFamilies.interDisplayExtraBold,\n    fontSize: fontSizes[72],\n    lineHeight: 81,\n  },\n  displayMd: {\n    fontFamily: fontFamilies.interDisplayExtraBold,\n    fontSize: fontSizes[57],\n    lineHeight: 64,\n  },\n  displaySm: {\n    fontFamily: fontFamilies.interDisplayExtraBold,\n    fontSize: fontSizes[51],\n    lineHeight: 57,\n  },\n  displayXs: {\n    fontFamily: fontFamilies.interDisplayExtraBold,\n    fontSize: fontSizes[45],\n    lineHeight: 51,\n  },\n  headingLg: {\n    fontFamily: fontFamilies.interSemiBold,\n    fontSize: fontSizes[40],\n    lineHeight: 50,\n  },\n  headingMd: {\n    fontFamily: fontFamilies.interSemiBold,\n    fontSize: fontSizes[28],\n    lineHeight: 35,\n  },\n  headingSm: {\n    fontFamily: fontFamilies.interSemiBold,\n    fontSize: fontSizes[22],\n    lineHeight: 28,\n  },\n  headingXs: {\n    fontFamily: fontFamilies.interSemiBold,\n    fontSize: fontSizes[18],\n    lineHeight: 23,\n  },\n  labelLg: {\n    fontFamily: fontFamilies.interMedium,\n    fontSize: fontSizes[18],\n    lineHeight: 24,\n  },\n  labelMd: {\n    fontFamily: fontFamilies.interMedium,\n    fontSize: fontSizes[16],\n    lineHeight: 22,\n  },\n  labelSm: {\n    fontFamily: fontFamilies.interMedium,\n    fontSize: fontSizes[14],\n    lineHeight: 19,\n  },\n  labelXs: {\n    fontFamily: fontFamilies.interMedium,\n    fontSize: fontSizes[12],\n    lineHeight: 16,\n  },\n  bodyLg: {\n    fontFamily: fontFamilies.interRegular,\n    fontSize: fontSizes[18],\n    lineHeight: 27,\n  },\n  bodyMd: {\n    fontFamily: fontFamilies.interRegular,\n    fontSize: fontSizes[16],\n    lineHeight: 24,\n  },\n  bodySm: {\n    fontFamily: fontFamilies.interRegular,\n    fontSize: fontSizes[14],\n    lineHeight: 21,\n  },\n  bodyXs: {\n    fontFamily: fontFamilies.interRegular,\n    fontSize: fontSizes[12],\n    lineHeight: 18,\n  },\n};\n\nexport const typography = {\n  fontFamilies,\n  fontSizes,\n  textVariants,\n} as const;\n",
  },
  {
    name: 'themes.ts',
    type: 'style',
    registryDependencies: [
      {
        name: 'tokens.ts',
        type: 'style',
      },
    ],
    code: "import {\n  lightThemeColors,\n  darkThemeColors,\n  radius,\n  space,\n  typography,\n} from './tokens';\n\nexport type Theme = {\n  colors: Record<keyof typeof lightThemeColors, string>;\n  radius: typeof radius;\n  space: typeof space;\n  typography: typeof typography;\n};\n\nexport const lightTheme: Theme = {\n  colors: lightThemeColors,\n  radius,\n  space,\n  typography,\n} as const;\n\nexport const darkTheme: Theme = {\n  colors: darkThemeColors,\n  radius,\n  space,\n  typography,\n};\n\nexport const themes = {\n  light: lightTheme,\n  dark: darkTheme,\n} as const;\n\nexport type Themes = typeof themes;\n",
  },
  {
    name: 'unistyles.ts',
    type: 'style',
    registryDependencies: [
      {
        name: 'themes.ts',
        type: 'style',
        registryDependencies: [
          {
            name: 'tokens.ts',
            type: 'style',
          },
        ],
      },
      {
        name: 'tokens.ts',
        type: 'style',
      },
    ],
    code: "/* eslint-disable @typescript-eslint/no-empty-object-type */\nimport { UnistylesRegistry } from 'react-native-unistyles';\n\nimport { Breakpoints, breakpoints } from './tokens';\nimport { themes, Themes } from './themes';\n\ndeclare module 'react-native-unistyles' {\n  export interface UnistylesBreakpoints extends Breakpoints {}\n  export interface UnistylesThemes extends Themes {}\n}\n\nUnistylesRegistry.addBreakpoints(breakpoints).addThemes(themes).addConfig({\n  adaptiveThemes: true,\n});\n",
  },
  {
    name: 'components.ts',
    type: 'type',
    code: "import React from 'react';\n\nexport type PolymorphicProps<T extends React.ElementType> =\n  React.ComponentPropsWithoutRef<T> & {\n    as?: T;\n  };\n",
  },
  {
    name: 'composeRefs.ts',
    type: 'utility',
    code: "import React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    (ref as React.MutableRefObject<T>).current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]) {\n  return (node: T) => refs.forEach((ref) => setRef(ref, node));\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n",
  },
  {
    name: 'genericForwardRef.ts',
    type: 'utility',
    code: "import * as React from 'react';\n\n/**\n * This is a workaround for `React.forwardRef` not supporting generics\n */\nfunction genericForwardRef<T, P>(\n  Component: (props: P, ref: React.ForwardedRef<T>) => React.ReactNode,\n): (props: P & React.RefAttributes<T>) => React.ReactNode {\n  return React.forwardRef(Component as any) as any;\n}\n\nexport { genericForwardRef };\n",
  },
];
